/**
 * File:	include/ipsec/dialogs.ycp
 * Package:	Configuration of ipsec
 * Summary:	Dialogs definitions
 * Authors:	Ludwig Nussel <lnussel@suse.de>
 *
 * $Id$
 */

{

textdomain "ipsec";

import "Label";
import "Wizard";
import "IPsec";
import "IPsecConfig";
import "Call";
import "ProductFeatures";

include "ipsec/helps.ycp";

/**
 * Configure1 dialog
 * @return dialog result
 */
any NewConnectionDialog () {

    /* IPsec configure1 dialog caption */
    string caption = _("Connection Configuration");

    /* IPsec configure1 dialog contents */
    term contents = `VBox(
	`HBox(
	    `HStretch(),
	    `Frame(_("Choose the connection type."),
		`RadioButtonGroup(`id(`rbg),
		    `VBox(
			`Left(`RadioButton(`id(`rws), _("Server for Road Warriors"), true)),
			`Left(`RadioButton(`id(`rwc), _("Road Warrior Client"))),
			`VSpacing(0.3),
			`Left(`RadioButton(`id(`custom), _("Custom")))
		    )
		)
	    ),
	    `HStretch()
	)
    );

    // edit mode. skip this dialog
    if(IPsec::current_connection_name != "")
    {
	if(IPsec::edit_start == true)
	{
	    string msg = IPsec::mayEditCurrentConnection();
	    if(msg != nil)
	    {
		Popup::Error(msg);
		return `back;
	    }
	    IPsec::edit_start = false;
	    return `edit;
	}
	return `back;
    }
    // not SLES
    else if(ProductFeatures::ui_mode == "simple")
    {
	IPsec::newClientConnection();
	return `rwc;
    }

    Wizard::SetContentsButtons(caption, contents, HELPS["newconnection"]:"",
	    Label::BackButton(), Label::NextButton());

    any ret = nil;
    while(true) {

	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(Popup::ReallyAbort(false)) break;
	    else continue;
	}
        else if(ret == `next)
	{
	    symbol type = (symbol) UI::QueryWidget(`id(`rbg), `CurrentButton);

	    if(type == `custom)
		IPsec::newConnection();
	    else if(type == `rws)
		IPsec::newServerConnection();
	    else if (type == `rwc)
		IPsec::newClientConnection();

	    ret = type;

	    break;
	}
	else if(ret == `back) {
            break;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}

string ConnectionNameTextEntryPopup(string headline, string txtlabel, string value)
{
    UI::OpenDialog(
	`VBox(
	    `Heading(headline),
	    `TextEntry(`id(`value), txtlabel, value),
	    `VSpacing(0.5),
	    `HBox(
		`PushButton(`id(`ok), `opt(`default), Label::OKButton()),
		`PushButton(`id(`cancel), Label::CancelButton())
	    )
	)
    );

    if( UI::UserInput() != `ok)
    {
	UI::CloseDialog();
	return nil;
    }

    string value = (string) UI::QueryWidget(`id(`value), `Value);

    UI::CloseDialog();

    return value;
}

any AskConnectionNamePopup()
{
    string headline = _("Enter the connection name.");
    // connection name
    string txtlabel = _("Name");
    string value = "";

    UI::OpenDialog(
	`VBox(
	    `Heading(headline),
	    `TextEntry(`id(`value), txtlabel, value),
	    `VSpacing(0.5),
	    `HBox(
		`PushButton(`id(`ok), `opt(`default), Label::OKButton()),
		`PushButton(`id(`cancel), Label::CancelButton())
	    )
	)
    );

    UI::ChangeWidget(`id(`value), `ValidChars, "-_0123456789abcdefghijklmnopqrstuvwxyz");
    UI::SetFocus(`id(`value));

    string name = nil;

    while(true)
    {
	any ret = UI::UserInput();
	if( ret != `ok)
	{
	    UI::CloseDialog();
	    return `back;
	}

	name = (string) UI::QueryWidget(`id(`value), `Value);

	string err = IPsecConfig::validConnectionName(name);

	if( err != nil )
	{
	    Popup::Error(err);
	}
	else
	    break;
    }

    UI::CloseDialog();

    if(size(IPsec::current_connection_name) != 0 && IPsec::current_connection_name != name)
    {
	IPsec::current_connection_oldname = IPsec::current_connection_name;
    }
    IPsec::current_connection_name = name;

    return `next;
}

void ReplaceLeftRightConnectionConfigDialogIdCombo(string cert, string value)
{
    y2error("%1 %2", cert, value);
    list<string> ids = IPsec::getIdsOfCert(cert);
    UI::ReplaceWidget(`id(`idcombo),
	`ComboBox(`id(`ident), `opt(`editable, `hstretch), _("Identification"), ids));
    if(value == "")
	value = ids[0]:"";
    UI::ChangeWidget(`id(`ident), `Value, value );
}

/**
 * Configure2 dialog
 * @param side "left" or "right"
 * @return dialog result
 */
any LeftRightConnectionConfigDialog(
    string iptext,
    string subnettext,
    string side,
    list ips,
    list networks)
{
    list certfiles = IPsec::getCertificateFiles();

    /* IPsec configure2 dialog caption */
    string caption = _("Connection Configuration");

    /* IPsec configure2 dialog contents */
    term contents = `HBox(
	`HStretch(),
	`VBox(
	    `ComboBox(`id(`addr), `opt(`editable, `hstretch), iptext, ips),
	    `VSpacing(1.5),
	    `VBox(
		`Left(`CheckBox(`id(`isgateway), `opt(`notify), _("Act as Gateway"))),
		`HBox(`HSpacing(3), `ComboBox(`id(`subnet), `opt(`editable, `hstretch), subnettext, networks))
	    ),
	    `VSpacing(2),
	    `HBox(
		`ComboBox(`id(`cert), `opt(`editable, `hstretch, `notify), _("Certificate"), certfiles),
		`PushButton(`id(`import), _("Import..."))
	    ),
	    `ReplacePoint(`id(`idcombo), `Empty())
	),
	`HStretch()
    );

    Wizard::SetContentsButtons(caption, contents, HELPS[side+"configdialog"]:"",
	    Label::BackButton(), Label::NextButton());

    string tmp = IPsec::current_connection[side]:"";
    if(side == "left" && tmp == "" )
	tmp = "%defaultroute";

    if(tmp != "")
	UI::ChangeWidget(`id(`addr), `Value, tmp );

    tmp = IPsec::current_connection[side+"cert"]:"";
    if (side == "left" && tmp == "")
    {
	tmp = certfiles[0]:"";
    }
    if (side == "right" || tmp != "")
	UI::ChangeWidget(`id(`cert), `Value, tmp );

    ReplaceLeftRightConnectionConfigDialogIdCombo(tmp, IPsec::current_connection[side+"id"]:"");

    tmp = IPsec::current_connection[side+"subnet"]:"";
    if(tmp == "")
    {
	UI::ChangeWidget(`id(`isgateway), `Value, false );
	UI::ChangeWidget(`id(`subnet), `Enabled, false );
    }
    else
    {
	UI::ChangeWidget(`id(`isgateway), `Value, true );
	UI::ChangeWidget(`id(`subnet), `Value, tmp );
    }

    UI::SetFocus(`id(`addr));

    any ret = nil;
    while(true) {

	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(Popup::ReallyAbort(false)) break;
	    else continue;
	}
        else if(ret == `next || ret == `back || ret == `import)
	{
	    string addr = (string) UI::QueryWidget(`id(`addr), `Value);
	    if(ret == `next && size(addr)==0)
	    {
		Popup::Message(_("You must specify an address."));
		UI::SetFocus(`id(`addr));
		continue;
	    }

	    boolean gw = (boolean) UI::QueryWidget(`id(`isgateway), `Value);
	    string subnet = (string) UI::QueryWidget(`id(`subnet), `Value);
	    if(ret == `next && gw == true && size(subnet)==0)
	    {
		Popup::Message(_("You must set a subnet address if you configure a gateway."));
		UI::SetFocus(`id(`subnet));
		continue;
	    }

	    string cert = (string) UI::QueryWidget(`id(`cert), `Value);
	    string ident = (string) UI::QueryWidget(`id(`ident), `Value);

	    if(ret == `next && size(cert)==0 && side == "left")
	    {
		Popup::Message(_("You must select a certificate."));
		UI::SetFocus(`id(`cert));
		continue;
	    }

	    IPsec::current_connection[side] = addr;
	    if(gw && subnet != "")
		IPsec::current_connection[side+"subnet"] = subnet;
	    else if(haskey(IPsec::current_connection, side+"subnet"))
		IPsec::current_connection = remove(IPsec::current_connection, side+"subnet");

	    IPsec::current_connection[side+"cert"] = cert;
	    IPsec::current_connection[side+"id"] = ident;

            break;
        }
	else if(ret == `isgateway)
	{
	    boolean gw = (boolean) UI::QueryWidget(`id(`isgateway), `Value);
	    UI::ChangeWidget(`id(`subnet), `Enabled, gw );
	}
	else if(ret == `cert)
	{
	    string cert = (string) UI::QueryWidget(`id(`cert), `Value);
	    ReplaceLeftRightConnectionConfigDialogIdCombo(cert, "");
	}
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}

any LeftConnectionConfigDialog ()
{
    list ips = IPsec::getIPaddresses();
    ips = add(ips, "%defaultroute");
    ips = add(ips, "%dynamic");

    list networks = IPsec::getNetworks();

    networks = add(networks, "0.0.0.0/0");

    return LeftRightConnectionConfigDialog(
	_("Local IP Address"),
	_("Local Subnet"),
	"left",
	ips, networks);
}

any RightConnectionConfigDialog ()
{
    list ips = [ "%any" ];

    list networks = [ "0.0.0.0/0" ];

    return LeftRightConnectionConfigDialog(
	_("Remote Address"),
	_("Remote Subnet"),
	"right",
	ips, networks);
}

any ConnectionStartModeDialog () {

    /* IPsec configure1 dialog caption */
    string caption = _("Connection Configuration");
    list bootmodes = IPsec::getBootModeItems();

    list<string> available_interfaces = IPsec::getDevices();

    /* IPsec configure1 dialog contents */
    term contents = `HBox(
	`HStretch(),
	`VBox(
	    `ComboBox(`id(`bootmode), `opt(`hstretch), _("During Boot..."), bootmodes ),
	    `Frame(_("Dynamic Start"), `RadioButtonGroup(`id(`rbg), `opt(`notify),
		`VBox(
		    `Left(`CheckBox(`id(`nodyncbx), `opt(`notify), _("Start Dynamically"))),
		    `ComboBox(`id(`netif), `opt(`editable), _("Interface"), available_interfaces)
		    )
		)
	    )
	),
	`HStretch()
    );

    Wizard::SetContentsButtons(caption, contents, HELPS["startmode"]:"",
	    Label::BackButton(), Label::OKButton());

    boolean left_is_dynamic = false;

    if(IPsec::current_connection["left"]:"" == "%dynamic")
    {
	left_is_dynamic = true;
    }

    {
	string val = IPsec::current_connection["auto"]:"";
	if(val != "")
	    UI::ChangeWidget(`id(`bootmode), `Value, IPsec::getBootModeText(val) );
    }

    {
	list<string> devs = IPsec::getNetworkDevicesUP();
	if(size(devs) == 0 && (IPsec::dynamic_start_suggest_dialup == true || left_is_dynamic == true))
	{
	    devs = IPsec::getDialupInterfaces();
	    IPsec::dynamic_start_suggest_dialup = false;
	}
	if(size(devs) != 0)
	{
	    UI::ChangeWidget(`id(`netif), `Value, mergestring(devs, " "));
	    UI::ChangeWidget(`id(`netif), `Enabled, true );
	    UI::ChangeWidget(`id(`nodyncbx), `Value, true );
	}
	else
	{
	    UI::ChangeWidget(`id(`netif), `Enabled, false );
	    if(size(available_interfaces) == 0)
	    {
		Popup::Message(_("You chose %dynamic as the local IP address, but no interfaces were found."));
	    }
	}
    }


    any ret = nil;
    while(true) {

	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel)
	{
	    if(Popup::ReallyAbort(false)) break;
	    else continue;
	}
	else if(ret == `nodyncbx)
	{
	    boolean netif = (boolean) UI::QueryWidget(`id(`nodyncbx), `Value);
	    UI::ChangeWidget(`id(`netif), `Enabled, netif );
	}
        else if(ret == `next || ret == `back)
	{
	    string mode = (string) UI::QueryWidget(`id(`bootmode), `Value);
	    IPsec::current_connection["auto"] = mode;

	    if((boolean) UI::QueryWidget(`id(`nodyncbx), `Value))
	    {
		if(!left_is_dynamic)
		{
		    if(IPsec::silently_use_left_dynamic || Popup::YesNo(sformat(_("You chose '%1' as the local IP address, but want to start the connection dynamically.
Set the local IP address to %%dynamic?
"), IPsec::current_connection["left"]:"")) == true)
		    {
			IPsec::current_connection["left"] = "%dynamic";
		    }
		}

		string devs = (string) UI::QueryWidget(`id(`netif), `Value);
		y2debug("devs=%1", devs);
		IPsec::setNetworkDevicesUP(splitstring(devs, " "));
	    }
	    else if(ret == `next && left_is_dynamic && mode != "ignore")
	    {
		Popup::Message(_("You chose %dynamic as the local IP address, but did not select an interface."));
		continue;
	    }
	    else
	    {
		IPsec::setNetworkDevicesUP([]);
	    }

            break;
        }
        else
	{
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}


/**
 * Dialog for global FreeS/WAN settings
 * @return dialog result
 */
any FreeSWANSettingsDialog ()
{
    // dialog headline
    string caption = IPsec::settings_str;

    term contents = `HBox (`HStretch(),
	`Frame(IPsec::settings_str,
	    `VBox(
		`VSpacing(0.5),
//		`Left(`CheckBox(`id(`startatboot), IPsec::start_str, IPsec::getStart())),
		`Left(`CheckBox(`id(`nattraversal), IPsec::nattraversal_str, IPsec::getNatTraversal())),
		`Left(`CheckBox(`id(`strictcrlpolicy), IPsec::strictcrlpolicy_str, IPsec::getStrictCRLPolicy())),
		`VSpacing(0.2),
		`Left(`IntField(`id(`crlcheckinterval), IPsec::crlcheckinterval_str, 0, 99999, IPsec::getCrlCheckInterval())),
		`VSpacing(0.7)
	    )
	), `HStretch()
    );

    Wizard::SetContentsButtons(caption, contents, HELPS["settings"]:"",
	    Label::BackButton(), Label::OKButton());

    any ret = nil;
    while(true) {

	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
        else if(ret == `next || ret == `back) {
//	    boolean startatboot = (boolean) UI::QueryWidget(`id(`startatboot), `Value);
	    boolean nattraversal = (boolean) UI::QueryWidget(`id(`nattraversal), `Value);
	    boolean strictcrlpolicy = (boolean) UI::QueryWidget(`id(`strictcrlpolicy), `Value);
	    integer crlcheckinterval = (integer) UI::QueryWidget(`id(`crlcheckinterval), `Value);

//	    IPsec::setStart(startatboot);
	    IPsec::setNatTraversal(nattraversal);
	    IPsec::setStrictCRLPolicy(strictcrlpolicy);
	    IPsec::setCrlCheckInterval(crlcheckinterval);
            break;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}

any ConnectionConfigEncryptionDialog () {

    /* IPsec configure1 dialog caption */
    string caption = _("Connection Configuration");

    /* IPsec configure1 dialog contents */
    term contents = `HBox(
	`HStretch(),
	`VBox(
	    `HBox(
		`Label(_("Encryption Algorithms")),
		`Label(`id(`encalgos), `opt(`outputField, `hstretch), "aes,blowfish,3des"),
		`PushButton(`id(`encalgobutton), _("Choose..."))
	    ),
	    `HBox(
		`Label(_("Authentication Algorithms")),
		`Label(`id(`authalgo), `opt(`outputField, `hstretch), ""),
		`PushButton(`id(`authalgobutton), _("Choose..."))
	    ),
	    /** Translator: you probably don't want to translate this, at least not PFS ;-) */
	    `CheckBox(_("Perfect Forward Secrecy (PFS)"))
	),
	`HStretch()
    );

    Wizard::SetContentsButtons(caption, contents, HELPS["c1"]:"",
	    Label::BackButton(), Label::NextButton());

    any ret = nil;
    while(true) {

	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(ReallyAbort()) break;
	    else continue;
	}
        else if(ret == `next || ret == `back) {
            break;
        }
        else if(ret == `encalgos)
	{
	    break;
	}
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}


any ConnectionDoneDialog ()
{
    IPsec::commitChangedConnection();
    return `next;
}

/**
 * Configure1 dialog
 * @return dialog result
 */
any EasyRoadWarriorServerDialog () {

    /* Roadwarrior Dialog caption */
    string caption = _("Create Server Connection");

    list certfiles = IPsec::getCertificateFiles();

    list networks = IPsec::getNetworks();

    list ips = IPsec::getIPaddresses();
    ips = add(ips, "%defaultroute");
    ips = add(ips, "%dynamic");

    term contents = `VBox(
	`HBox(
	    `HStretch(),
	    `Frame(_("Server Connection Settings"),
		`VBox(
		    `ComboBox(`id(`addr), `opt(`editable, `hstretch), _("Local IP Address"), ips),
		    `Left(`VSpacing(1.5)),
		    `Left(`CheckBox(`id(`isgateway), `opt(`notify), _("Act as Gateway"), true)),
		    `Left(`HBox(`HSpacing(3), `ComboBox(`id(`subnet), `opt(`editable), _("Network"), networks))),
		    `Left(`ComboBox(`id(`cert), _("Certificate"), certfiles))
		)
	    ),
	    `HStretch()
	)
    );

    Wizard::SetContentsButtons(caption, contents, HELPS["easyroadwarriorserver"]:"",
	    Label::BackButton(), Label::NextButton());

    if(size(certfiles) == 0)
    {
	if(Popup::ContinueCancel(_("Import certificates first.
Press 'Continue' to import certificates now.
")))
	    return `needcert;
	return `back;
    }

    string tmp = IPsec::current_connection["left"]:"";
    if(tmp == "")
	tmp = "%defaultroute";
    if(tmp != "")
	UI::ChangeWidget(`id(`addr), `Value, tmp );

    tmp = IPsec::current_connection["leftsubnet"]:"";
    if(tmp == "")
    {
	UI::ChangeWidget(`id(`isgateway), `Value, false );
	UI::ChangeWidget(`id(`subnet), `Enabled, false );
    }
    else
    {
	UI::ChangeWidget(`id(`isgateway), `Value, true );
	UI::ChangeWidget(`id(`subnet), `Value, tmp );
    }

    tmp = IPsec::current_connection["leftcert"]:"";
    if (tmp != "")
	UI::ChangeWidget(`id(`cert), `Value, tmp );


    UI::SetFocus(`id(`isgateway));

    any ret = nil;
    while(true)
    {
	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(Popup::ReallyAbort(false)) break;
	    else continue;
	}
        else if(ret == `next)
	{
	    string addr = (string) UI::QueryWidget(`id(`addr), `Value);
	    if(size(addr) == 0)
	    {
		Popup::Message(_("You must specify the local address."));
		UI::SetFocus(`id(`addr));
		continue;
	    }

	    boolean gw = (boolean) UI::QueryWidget(`id(`isgateway), `Value);
	    string subnet = (string) UI::QueryWidget(`id(`subnet), `Value);
	    if(gw == true && size(subnet)==0)
	    {
		Popup::Message(_("You must set a subnet address if you configure a gateway."));
		UI::SetFocus(`id(`subnet));
		continue;
	    }

	    if(gw == false)
		subnet = "";

	    string cert = (string) UI::QueryWidget(`id(`cert), `Value);
	    list<string> ids = IPsec::getIdsOfCert(cert);

	    IPsec::current_connection["left"] = addr;
	    IPsec::current_connection["leftcert"] = cert;
	    // well, just use first one. should be subjectAltName
	    IPsec::current_connection["leftid"] = ids[0]:"";

	    if(gw && subnet != "")
		IPsec::current_connection["leftsubnet"] = subnet;
	    else if(haskey(IPsec::current_connection, "leftsubnet"))
		IPsec::current_connection = remove(IPsec::current_connection, "leftsubnet");

	    if(IPsec::dynamic_start_suggest_dialup == nil)
	    {
		IPsec::dynamic_start_suggest_dialup = true;
	    }
	    break;
	}
	else if(ret == `back) {
	    IPsec::setNoConnection();
            break;
        }
	else if(ret == `isgateway)
	{
	    boolean gw = (boolean) UI::QueryWidget(`id(`isgateway), `Value);
	    UI::ChangeWidget(`id(`subnet), `Enabled, gw );
	}
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}

/**
 * Configure1 dialog
 * @return dialog result
 */
any EasyRoadWarriorClientDialog () {

    /* Roadwarrior Dialog caption */
    string caption = _("Create Client Connection");

    list certfiles = IPsec::getCertificateFiles();

    term contents = `VBox(
	`HBox(
	    `HStretch(),
	    `Frame(_("Connection Settings"),
		`VBox(
		    `Left(`TextEntry(`id(`addr), `opt(`hstretch), _("Server Address"))),
		    `Left(`VSpacing(1.5)),
		    `Left(`CheckBox(`id(`isgateway), `opt(`notify), _("Server Acts as Gateway"), true)),
		    `Left(`HBox(`HSpacing(3), `TextEntry(`id(`subnet), _("Network")))),
		    `Left(`TextEntry(`id(`rightid), _("Server Identification"))),
		    `VSpacing(0.5),
		    `Left(`ComboBox(`id(`cert), _("Certificate"), certfiles))
		)
	    ),
	    `HStretch()
	)
    );

    Wizard::SetContentsButtons(caption, contents, HELPS["easyroadwarriorclient"]:"",
	    Label::BackButton(), Label::NextButton());

    if(size(certfiles) == 0)
    {
	if(Popup::ContinueCancel(_("Import certificates first.
Press 'Continue' to import certificates now.
")))
	    return `needcert;
	return `back;
    }

    string tmp = IPsec::current_connection["rightsubnet"]:"";
    if(tmp == "")
    {
	UI::ChangeWidget(`id(`isgateway), `Value, false );
	UI::ChangeWidget(`id(`subnet), `Enabled, false );
    }
    else
    {
	UI::ChangeWidget(`id(`isgateway), `Value, true );
	UI::ChangeWidget(`id(`subnet), `Value, tmp );
    }

    tmp = IPsec::current_connection["leftcert"]:"";
    if (tmp != "")
	UI::ChangeWidget(`id(`cert), `Value, tmp );

    tmp = IPsec::current_connection["right"]:"";
    if (tmp != "")
	UI::ChangeWidget(`id(`addr), `Value, tmp );

    tmp = IPsec::current_connection["rightid"]:"";
    if (tmp != "")
	UI::ChangeWidget(`id(`rightid), `Value, tmp );


    UI::SetFocus(`id(`addr));

    any ret = nil;
    while(true)
    {
	ret = UI::UserInput();

	/* abort? */
	if(ret == `abort || ret == `cancel) {
	    if(Popup::ReallyAbort(false)) break;
	    else continue;
	}
        else if(ret == `next)
	{
	    string addr = (string) UI::QueryWidget(`id(`addr), `Value);
	    if(size(addr) == 0)
	    {
		Popup::Message(_("Specify the remote address."));
		UI::SetFocus(`id(`addr));
		continue;
	    }

	    string rightid = (string) UI::QueryWidget(`id(`rightid), `Value);
	    if(size(rightid) == 0)
	    {
		Popup::Message(_("Specify the remote identification."));
		UI::SetFocus(`id(`rightid));
		continue;
	    }

	    boolean gw = (boolean) UI::QueryWidget(`id(`isgateway), `Value);
	    string subnet = (string) UI::QueryWidget(`id(`subnet), `Value);
	    if(gw == true && size(subnet)==0)
	    {
		Popup::Message(_("Specify a subnet address if the remote acts as gateway."));
		UI::SetFocus(`id(`subnet));
		continue;
	    }

	    if(gw == false)
		subnet = "";

	    string cert = (string) UI::QueryWidget(`id(`cert), `Value);
	    list<string> ids = IPsec::getIdsOfCert(cert);

	    IPsec::current_connection["leftcert"] = cert;
	    // well, just use first one. should be subjectAltName
	    IPsec::current_connection["leftid"] = ids[0]:"";

	    if(gw && subnet != "")
		IPsec::current_connection["rightsubnet"] = subnet;
	    else if(haskey(IPsec::current_connection, "rightsubnet"))
		IPsec::current_connection = remove(IPsec::current_connection, "rightsubnet");

	    IPsec::current_connection["right"] = addr;
	    IPsec::current_connection["rightid"] = rightid;

	    if(IPsec::dynamic_start_suggest_dialup == nil)
	    {
		IPsec::dynamic_start_suggest_dialup = true;
	    }
	    break;
	}
	else if(ret == `back) {
	    IPsec::setNoConnection();
            break;
        }
	else if(ret == `isgateway)
	{
	    boolean gw = (boolean) UI::QueryWidget(`id(`isgateway), `Value);
	    UI::ChangeWidget(`id(`subnet), `Enabled, gw );
	}
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }
    }

    return ret;
}

/**
 * export a connection
 * @return dialog result
 */
any ExportConnectionDialog ()
{
    boolean freeswan = Popup::AnyQuestion( _("File Format"),
	_("Select the export file format."),
	_("FreeS/WAN"),
	// the operating system
	_("Windows") + " (TM)", `focus_yes ); // XXX move that tm

    string file = UI::AskForSaveFileName( IPsec::exportdir + "/" + (freeswan?"freeswan":"windows") + "-ipsec.conf",
	    "",
	    _("Specify a file name for export."));

    IPsec::updateExportDir(file);

    if(file == nil)
	return `back;

    string error = IPsecConfig::exportConnection(IPsec::current_connection_name, file, freeswan);
    if( error != nil )
    {
	// %1: Error message
	Popup::Error(sformat(_("Could not export selected connection:\n%1"), error));
    }

    return `next;
}

/**
 * import a connection
 * @return dialog result
 */
any ImportConnectionDialog ()
{
    string file = UI::AskForExistingFile( IPsec::certimportdir,
	    "*.zip *.ZIP ipsec.conf",
	    _("Choose the file to import."));

    IPsec::updateImportDir(file);

    if(file == nil)
	return `back;

    string error = IPsecConfig::importConnection(file);
    if( error != nil )
    {
	// %1: Error message
	Popup::Error(sformat(_("Could not import selected file:\n%1"), error));
    }

    return `next;
}


symbol FinishDialog ()
{
    if(IPsec::getStart() && IPsec::needaskfirewall == true)
    {
	if(Popup::YesNo(_("SuSEfirewall is enabled but currently denies IPsec traffic.
Reconfigure SuSEfirewall?
")))
	{
	    Call::Function("firewall", []);
	}
    }
    return `next;
}

/* EOF */
}
