#!/usr/bin/perl -w

use OpenCA::OpenSSL;
use OpenCA::X509;
use OpenCA::CRL;

use lib "/usr/lib/YaST2/agents_non_y2";
use ycp;

use strict;

my $ipsecdir  = "/etc/ipsec.d/";
my $certdir   = $ipsecdir."certs/";
my $cacertdir = $ipsecdir."cacerts/";
my $crldir    = $ipsecdir."crls/";
my $keydir    = $ipsecdir."private/";

sub evalHash($$);

sub evalArray($$)
{
    my $reference = shift;
    my $cnt       = shift;
    
    foreach my $value (@{$reference}) {
        print " "x$cnt;
	
	if (length $value > 40)
	{
	    $value = substr($value, 0, 40);
	    $value .= " ...";
	}

	print "@ $value\n";
    }
}

sub evalHash($$)
{
    my $reference = shift;
    my $cnt       = shift;

    foreach my $key (sort keys %{$reference}) {
	my $type = ref $reference->{$key};
        if( $type eq "HASH" ) {
	    print " "x$cnt;
            print "- $key = HASH\n";
            evalHash($reference->{$key}, $cnt+4);
        } elsif( $type eq "ARRAY" ) {
	    print " "x$cnt;
            print "- $key = ARRAY\n";
            evalArray($reference->{$key}, $cnt+4);
        } else {
	    my $value = $reference->{$key};
	    if (!defined $value)
	    {
		$value = "(UNDEF)";
	    }
	    $value =~ s/\n.*/\\n/g;
	    if (length $value > 40)
	    {
		$value = substr($value, 0, 40);
		$value .= " ...";
	    }
	    print " "x$cnt;
            print "- $key = $value\n";
        }
    }
}

# return array of certificate file names, relative to /etc/ipsec.d/certs
sub certfiles()
{
    my @certs;
    opendir(DIR, $certdir) or return @certs;
    @certs = grep { !/^\./ && /.*\.pem/ } readdir(DIR);
    closedir DIR;
    return @certs;
}

# return array of certificate file names, relative to /etc/ipsec.d/certs
sub cacertfiles()
{
    my @certs;
    opendir(DIR, $cacertdir) or return @certs;
    @certs = grep { !/^\./ && /.*\.pem/ } readdir(DIR);
    closedir DIR;
    return @certs;
}

# return array of certificate file names, relative to /etc/ipsec.d/certs
sub crlfiles()
{
    my @certs;
    opendir(DIR, $crldir) or return @certs;
    @certs = grep { !/^\./ && /.*\.pem/ } readdir(DIR);
    closedir DIR;
    return @certs;
}

# return a certificate hash
# a certificate contains DN, ISSUER and subjectAltName
sub parsecert($$)
{
    my $openssl = shift;
    my $file = shift;

    my $X509 = new OpenCA::X509(INFILE=>$file , SHELL=>$openssl);

    if (not $X509)
    {
	print STDERR "ERROR reading $file\n";
	return undef;
    }

    my $parsed = $X509->getParsed();
    my $subjaltname;

    if(exists $parsed->{"OPENSSL_EXTENSIONS"}
	&& ref $parsed->{"OPENSSL_EXTENSIONS"} eq "HASH")
    {
	my $arref = $parsed->{"OPENSSL_EXTENSIONS"};
	if(exists($arref->{"X509v3 Subject Alternative Name"}))
	{
	    # just use the first one
	    $subjaltname = $arref->{"X509v3 Subject Alternative Name"}[0];

	    # FIXME: do we need to add @ for DNS?
	    $subjaltname =~ s/^(email|IP|DNS)://;
	}
    }
    
    my %cert;
    $cert{"DN"}=$parsed->{"DN"};
    $cert{"ISSUER"}=$parsed->{"ISSUER"};
    $cert{"subjectAltName"}=$subjaltname;

    return %cert;
}

# return a CRL hash
# a CRL contains ISSUER, NEXT_UPDATE and LAST_UPDATE
sub parsecrl($$)
{
    my $openssl = shift;
    my $file = shift;

    my $CRL = new OpenCA::CRL(INFILE=>$file , SHELL=>$openssl);

    if (not $CRL)
    {
	print STDERR "ERROR reading $file\n";
	return undef;
    }

    my $parsed = $CRL->getParsed();
    my $subjaltname;

    if(exists $parsed->{"OPENSSL_EXTENSIONS"}
	&& ref $parsed->{"OPENSSL_EXTENSIONS"} eq "HASH")
    {
	my $arref = $parsed->{"OPENSSL_EXTENSIONS"};
	if(exists($arref->{"X509v3 Subject Alternative Name"}))
	{
	    # just use the first one
	    $subjaltname = $arref->{"X509v3 Subject Alternative Name"}[0];

	    # FIXME: do we need to add @ for DNS?
	    $subjaltname =~ s/^(email|IP|DNS)://;
	}
    }
    
    my %cert;
    $cert{"ISSUER"}=$parsed->{"ISSUER"};
    $cert{"NEXT_UPDATE"}=$parsed->{"NEXT_UPDATE"};
    $cert{"LAST_UPDATE"}=$parsed->{"LAST_UPDATE"};

    return %cert;
}

# return hash of certificates indexed by filename
sub readcertificates($)
{
    my $openssl = shift;

    my %certificates;

    foreach my $file (certfiles())
    {
	my %cert = parsecert($openssl,$certdir.$file);
	next unless %cert;
	$certificates{$file} = \%cert;
    }

    return %certificates;
}

# return hash of CA certificates indexed by filename
sub readcacertificates($)
{
    my $openssl = shift;

    my %certificates;

    foreach my $file (cacertfiles())
    {
	my %cert = parsecert($openssl,$cacertdir.$file);
	next unless %cert;
	$certificates{$file} = \%cert;
    }

    return %certificates;
}

# return hash of CRLs indexed by filename
sub readcrls($)
{
    my $openssl = shift;

    my %crls;

    foreach my $file (crlfiles())
    {
	my %crl = parsecrl($openssl,$crldir.$file);
	next unless %crl;
	$crls{$file} = \%crl;
    }

    return %crls;
}

sub main()
{
    my $openssl = new OpenCA::OpenSSL( SHELL=>"/usr/bin/openssl" );

    while(<STDIN>)
    {
	my ($command, $path, $arg ) = ycp::ParseCommand( $_ );

	$command = "" unless $command;
	$path = "" unless $path;
	$arg = "" unless $arg;

	if( $command eq "Read" && $path eq ".certs")
	{
	    my %certs = readcertificates($openssl);
	    ycp::Return( \%certs );
	}
	elsif( $command eq "Read" && $path eq ".cacerts")
	{
	    my %cacerts = readcacertificates($openssl);
	    ycp::Return( \%cacerts );
	}
	elsif( $command eq "Read" && $path eq ".crls")
	{
	    my %crls = readcrls($openssl);
	    ycp::Return( \%crls );
	}
	elsif( $command eq "Read" && $path eq ".keys")
	{
	    # TODO
	    my %keys = ();
	    ycp::Return( \%keys );
	}
	# result: we must exit
	elsif ($command eq "result")
	{
	    y2debug ("got result -> say goodbye!");
	    last;
	}
	else
	{
	    y2error(sprintf( "Unknown instruction %s on %s argument: %s", $command, $path, $arg));
	    ycp::Return( () );
	}
    }


#    print "Certificates:\n";
#    evalHash(\%certificates, 0);
#    print "CA Certificates:\n";
#    evalHash(\%cacertificates, 0);
#    print "CRLs:\n";
#    evalHash(\%crls, 0);
}

main();


exit 0; 
