/**
 * File:	modules/IPsec.ycp
 * Package:	Configuration of ipsec
 * Summary:	IPsec settings, input and output functions
 * Authors:	Ludwig Nussel <lnussel@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of ipsec.
 * Input and output routines.
 */

{

module "IPsec";
textdomain "ipsec";

import "IPsecConfig";
import "Progress";
import "Runlevel";
import "Report";
import "Summary";
import "Mode";
import "NetworkDevices";
import "Netmask";

/**
 * Prototypes
 */
global boolean Modified();

global list<string> getNetworkDevicesUP();
global boolean setNetworkDevicesUP(list devices);

global boolean setCurrentConnection(string name);

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    return AbortFunction();
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2milestone("modified=%1",modified);
    return modified;
}

/** whether the summary dialog already asked the user to import certificates */
global boolean didaskaboutemptycertificates = false;

/** whether the summary dialog already asked the user to add connections */
global boolean didaskaboutemptyconnections = false;

/**
 * map of strings
 *  +-> "nat_traversal" = "yes"
 *  +-> "rp_filter" = "%unchanged"
 *  ...
 */
map<string, string> settings = $[];

/** default value. FIXME: get from lower layer? */
boolean default_strictcrlpolicy = false;

boolean strictcrlpolicy = false;

/** default value. FIXME: get from lower layer? */
integer default_crlcheckinterval = 0;

integer crlcheckinterval = 0;

/** default value. FIXME: get from lower layer? */
boolean default_nat_traversal = false;

boolean nat_traversal = false;

/** whether FreeS/WAN is started at boot */
boolean start = false;

/** whether to start FreeS/WAN at boot. Sets modified flag */
global void setStart(boolean val)
{
    if(val != start)
    {
	modified = true;
	start = val;
    }
}

/** determine whether FreeS/WAN is started at boot */
global boolean getStart()
{
    return start;
}

/** set strictcrlpolicy. Sets modified flag */
global void setStrictCRLPolicy(boolean val)
{
    if(val != strictcrlpolicy)
    {
	modified = true;
	strictcrlpolicy = val;
    }
}

/** @return whether strictcrlpolicy is set */
global boolean getStrictCRLPolicy()
{
    return strictcrlpolicy;
}

/** set nat_traversal. Sets modified flag */
global void setNatTraversal(boolean val)
{
    if(val != nat_traversal)
    {
	modified = true;
	nat_traversal = val;
    }
}

/** @return whether nat_traversal is set */
global boolean getNatTraversal()
{
    return nat_traversal;
}

/** set crlcheckinterval. Sets modified flag */
global void setCrlCheckInterval(integer val)
{
    if(val != crlcheckinterval)
    {
	modified = true;
	crlcheckinterval = val;
    }
}

/** @return crlcheckinterval */
global integer getCrlCheckInterval()
{
    return crlcheckinterval;
}

/**
 * map of maps of strings
 * connections
 *  +-> "roadwarrior"
 *  |    +-> "left" = "10.10.0.1"
 *  |    +-> "right" = "%any"
 *  |    \-> "auto" = "start"
 *  |
 *  \-> "conn2"
 *       +-> "left" = "10.10.0.1"
 *       \-> "right" = "10.10.5.5"
 */
map<string, map<string, string> > connections = $[];

/** one connection, used during add or edit */
global map<string,string> current_connection = $[];
global string current_connection_name = "";
// old name if connection was renamed
global string current_connection_oldname = "";

/** start directory for fileselection dialogs */
global string certimportdir = "/etc/ipsec.d"; //TODO change to /media

global string start_str = _("Activate during boot");
global string strictcrlpolicy_str =  _("strict CRL policy");
global string crlchekinterval_str =  _("CRL check interval");
global string nattraversal_str =  _("NAT traversal");
global string settings_str = _("Global settings");

/** return "Yes" or "No" */
string b2yn(boolean val)
{
    if (val == true)
	return _("Yes");
    return _("No");
}

/**
 */
map<string, map<string, string> > FakeConnections()
{
    return $[
	"roadwarrior" :
	    $[
		"left" : "%defaultroute",
		"right": "%any",
		"keyingtries": "3",
		"leftcert": "cert.pem",
		"leftrsasigkey": "%cert",
		"rightrsasigkey": "%cert",
		"pfs": "yes",
		"auto": "add",
	    ],
	"ipv6" :
	    $[
		"left" : "2001:780:101:a00:2e0:4cff:fe9f:619a",
		"right": "2001:780:101:a00:200:1cff:fee5:a796",
		"keyingtries": "3",
		"leftcert": "cert.pem",
		"leftrsasigkey": "%cert",
		"rightrsasigkey": "%cert",
		"leftid": "root@hewitt.suse.de",
		"rightid": "root@laptop",
		"pfs": "yes",
		"auto": "ignore",
	    ]
    ];
}

map FakeCertificates()
{
    return $[
	"cert.pem" :
	    $[
		"DN" : "/C=DE/ST=Franken/L=Nuernberg/O=SUSE/OU=Entwicklung/CN=hewitt.suse.de/emailAddress=root@hewitt.suse.de",
		"subjectAltName" : "root@hewitt.suse.de"
	    ]
    ];
}

map FakeCACertificates()
{
    return $[
	"cacert.pem" :
	    $[
		"DN" : "/C=DE/ST=Franken/L=Nuernberg/O=SUSE/OU=Entwicklung/CN=ca26test/emailAddress=root@hewitt.suse.de",
		"subjectAltName" : "root@hewitt.suse.de"
	    ]
    ];
}

list bootmodes = [ "start", "add", "ignore" ];
list bootmodes_str = [ _("Initiate Connection"), _("Prepare Connection"), _("Ignore Connection") ];

/** return list of `item(`id("bootmode"), "text")
 * if current connection has right == %any, start will be omitted
 * */
global list getBootModeItems()
{
    integer i = 0;
    integer max = size(bootmodes);

    list items = [];

    // start is invalid for %any
    if(size(current_connection) > 0
	&& current_connection["right"]:"" == "%any")
    {
	i = i + 1;
    }

    while(i < max )
    {
	items = add(items, `item(`id(bootmodes[i]:""), bootmodes_str[i]:""));
	i = i + 1;
    }

    return items;
}

/** return text for bootmode, e.g. "auto" -> "initiate connection" */
global string getBootModeText(string mode)
{
    integer i = 0;
    integer max = size(bootmodes);

    while(i < max )
    {
	if(bootmodes[i]:"" == mode)
	    return bootmodes_str[i]:mode;
	i = i + 1;
    }

    return mode;
}

/** remember directory
 * @param file the file from which the directory name is stored
 * @return
 */
global boolean updateImportDir(string file)
{
    if(file == nil) return false;
    integer lastslash = findlastof(file,"/");
    if(lastslash != nil)
    {
	certimportdir = substring(file,0,lastslash);
    }
    return true;
}

/** get value from settings map an convert into integer */
integer settingtointeger(string key, integer deflt)
{
    if(!haskey(settings,key)) return deflt;

    integer val = tointeger(settings[key]:"");
    if(val == nil)
    {
	y2warning("key %s has no integer value", key);
	return deflt;
    }

    return val;
}

/** get value from settings map an convert into boolean */
boolean settingtoboolean(string key, boolean deflt)
{
    if(!haskey(settings,key)) return deflt;

    string val = tolower(settings[key]:"");

    if(val == "no" || val == "false" || val == "0")
    {
	return false;
    }
    else if(val == "yes" || val == "true" || val == "1")
    {
	return true;
    }
    else if(val == nil)
    {
	y2warning("key %s has no boolean value", key);
	return deflt;
    }
}

/**
 * Read all ipsec settings
 * @return true on success
 */
global boolean Read() {

    /* IPsec read dialog caption */
    string caption = _("Initializing ipsec Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 4;

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read /etc/ipsec.conf"),
	    /* Progress stage 2/3 */
	    _("Read certificates"),
	    /* Progress stage 3/3 */
	    _("Read network settings")
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress step 2/3 */
	    _("Reading the previous settings..."),
	    /* Progress step 3/3 */
	    _("Reading network settings..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    if(Abort()) return false;
    Progress::NextStep();

    if(Mode::test == true)
    {
	connections = FakeConnections();
    }
    else
    {
	IPsecConfig::Read();

	connections = IPsecConfig::Connections();
	if(connections == nil)
	    connections = $[];
	settings    = IPsecConfig::Settings();
	if(settings == nil) {
	    settings = $[];
	}

	strictcrlpolicy  = settingtoboolean("strictcrlpolicy", default_strictcrlpolicy);
	crlcheckinterval = settingtointeger("crlcheckinterval", default_crlcheckinterval);
	nat_traversal    = settingtoboolean("nat_traversal", default_nat_traversal);
    }

    if(Abort()) return false;
    Progress::NextStage();

    start = Runlevel::ServiceEnabled("ipsec");

    if(Mode::test == true)
    {
	IPsecConfig::enableTestMode();
    }

/*
    certificates = (map)SCR::Read(.etc.ipsec.d.certs);
    cacertificates = (map)SCR::Read(.etc.ipsec.d.cacerts);
    crls = (map)SCR::Read(.etc.ipsec.d.crls);
    keys = (map)SCR::Read(.etc.ipsec.d.private);

    if(certificates == nil) certificates = $[];
    if(cacertificates == nil) cacertificates = $[];
    if(crls == nil) crls = $[];
    if(keys == nil) keys = $[];
*/

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(_("Cannot read current settings."));

    // detect devices
    if(Abort()) return false;
    Progress::NextStage();

    if(!Mode::test && !NetworkDevices::Read())
    {
	Report::Warning(_("Cannot read network settings."));
    }


    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    modified = false;
    return true;
}

/** no i18n */
string boolean2yesorno(boolean val)
{
    if(val)
	return "yes";
    return "no";
}


/**
 * Write all ipsec settings
 * @return true on success
 */
global boolean Write()
{
    if(!modified) return true;

    /* IPsec read dialog caption */
    string caption = _("Saving IPsec Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 3;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Write IPsec settings"),
	    /* Progress stage 2/3 */
	    _("Write Network settings"),
	    /* Progress stage 3/3 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/3 */
	    _("Writing IPsec settings..."),
	    /* Progress step 2/3 */
	    _("Writing Network settings..."),
	    /* Progress step 2/3 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));

    settings["nat_traversal"] = boolean2yesorno(nat_traversal);
    settings["strictcrlpolicy"] = boolean2yesorno(strictcrlpolicy);
    settings["crlchekinterval"] = sformat("%1", crlcheckinterval);

    IPsecConfig::setSettings(settings);
    if(!IPsecConfig::Write())
	Report::Error (_("Cannot write IPsec settings."));

    // Write Network settings
    if(Abort()) return false;
    Progress::NextStage ();
    if(!NetworkDevices::Write(""))
	Report::Error (_("Writing Network settings failed."));

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all ipsec settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the ipsec settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * @param conn a connection map
 * @param name localized name for summary
 * @param key key name in connection map
 * */
string addConnectionValueIfDefined(map conn, string name, string key)
{
    if(haskey(conn, key))
	return sformat("<li>%1: %2</li>", name, getBootModeText(conn[key]:""));
    return "";
}

/** create summary of connections */
string ConnectionSummary()
{
    string summary = sformat ("<p><a href=\"connections\">%1</a><br>", "Connections");
    summary = summary + "<ul>";

    if(size(connections) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No Connections defined"));
    }
    else
    {
	foreach(string name, map conn, connections, ``{
	    summary = summary + sformat("<li>%1</li>", name);
	    summary = summary + "<ul type=\"square\">";
	    summary = summary + addConnectionValueIfDefined(conn, _("Startmode"), "auto");

	    setCurrentConnection(name);

	    list<string> devs = getNetworkDevicesUP();
	    if(size(devs) != 0)
	    {
	       summary = summary + sformat("<li>%1: %2</li>", _("Initiate with Interfaces "), mergestring(devs, ", "));
	    }

	    summary = summary + "</ul>";
	});
    }

    summary = summary + "</ul></p>";

    return summary;
}

/** create summary of certificates */
string CertificateSummary()
{
    string summary = sformat ("<p><a href=\"certificates\">%1</a><br>", "Certificates");
    summary = summary + "<ul>";

    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    if(size(certificates) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No Certificates installed"));
    }
    else
    {
	foreach(string name, map cert, certificates, ``{
	    summary = summary + sformat("<li>%1: %2</li>", _("Certificate"), name);
	    summary = summary + "<ul type=\"square\">";
	    summary = summary + sformat("<li>Subject: %1</li>", cert["subjectAltName"]:"?");
	    summary = summary + sformat("<li>DN: %1</li>", cert["DN"]:"?");
	    summary = summary + "</ul>";
	});
    }

    map<string,map<string,string> > cacertificates = IPsecConfig::Certificates();

    if(size(cacertificates) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No CA Certificates installed"));
    }
    else
    {
	foreach(string name, map cert, cacertificates, ``{
	    summary = summary + sformat("<li>%1: %2</li>", _("CA Certificate"), name);
	    summary = summary + "<ul type=\"square\">";
	    summary = summary + sformat("<li>Subject: %1</li>", cert["subjectAltName"]:"?");
	    summary = summary + sformat("<li>DN: %1</li>", cert["DN"]:"?");
	    summary = summary + "</ul>";
	});
    }


    summary = summary + "</ul></p>";

    return summary;
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    /* Configuration summary text for autoyast */
    string summary = sformat ("<p><a href=\"settings\">%1</a><br>", settings_str);
    summary = summary + "<ul>";
    summary = summary + sformat("<li>%1: %2</li>", start_str, b2yn(getStart()));
    summary = summary + sformat("<li>%1: %2</li>", strictcrlpolicy_str, b2yn(getStrictCRLPolicy()));
    if(getCrlCheckInterval() != 0)
    {
	summary = summary + sformat("<li>%1: %2</li>", crlchekinterval_str,
	    sformat(_("%1 second", "%1 seconds", getCrlCheckInterval()), getCrlCheckInterval()));
    }
    summary = summary + sformat("<li>%1: %2</li>", nattraversal_str, b2yn(getNatTraversal()));
    summary = summary + "</ul></p>";

    summary = summary + CertificateSummary();

    summary = summary + ConnectionSummary();

    return [ summary, [] ];
}

/** returns whether there are connections at all */
global boolean haveConnections()
{
    return (size(connections) > 0);
}

/** returns whether there are certificates at all */
global boolean haveCertificates()
{
    return (size(IPsecConfig::Certificates()) > 0);
}

/**
 * Create an overview table with all configured connections
 * @return table items
 */
global list Overview() {
    list overview = [];

    foreach(string name, map conn, connections, ``{
	overview = add(overview, `item(`id(name), name, conn["left"]:"?", conn["right"]:"?"));
    });

    return overview;
}

global list CertOverview()
{
    list overview = [];

    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    foreach(string name, map cert, certificates, ``{
	overview = add(overview, `item(`id(name), name, cert["DN"]:"?"));
    });

    return overview;
}

global list CACertOverview()
{
    list overview = [];

    map<string,map<string,string> > cacertificates = IPsecConfig::CACertificates();

    foreach(string name, map cert, cacertificates, ``{
	overview = add(overview, `item(`id(name), name, cert["DN"]:"?"));
    });

    return overview;
}

global list CRLOverview()
{
    list overview = [];

    map<string,map<string,string> > crls = IPsecConfig::CRLs();

    foreach(string name, map cert, crls, ``{
	overview = add(overview, `item(`id(name), name, cert["NEXT_UPDATE"]:"?", cert["ISSUER"]:"?"));
    });

    return overview;
}

global list KeyOverview()
{
    list overview = [];

    map<string,map<string,string> > keys = IPsecConfig::Keys();

    foreach(string name, map cert, keys, ``{
	overview = add(overview, `item(`id(name), name));
    });

    return overview;
}

global void deleteCACert(string name)
{
    IPsecConfig::deleteCACertificate(name);
}

global void deleteCert(string name)
{
    IPsecConfig::deleteCertificate(name);
}

global void deleteKey(string name)
{
    IPsecConfig::deleteKey(name);
}

global void deleteCRL(string name)
{
    IPsecConfig::deleteCRL(name);
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    return $[ "install":[ "freeswan" ], "remove":[] ];
}

/**
 * empty any information about editing an existing connection
 * */
global void setNoConnection()
{
    current_connection = $[];
    current_connection_name = "";
    current_connection_oldname = "";
}

/**
 * prepare a new connection for editing
 * */
global void newConnection()
{
    current_connection = IPsecConfig::newRoadWarriorConnection();
    current_connection_name = "";
    current_connection_oldname = "";
}

global void newRoadWarriorConnection()
{
    current_connection = IPsecConfig::newRoadWarriorConnection();
    current_connection_name = "roadwarrior";
    current_connection_oldname = "";

    integer i = 0;
    foreach(string name, map conn, connections, ``{
	if(substring(name, 0, 11) == "roadwarrior")
	{
	    i = i + 1;
	}
    });

    if(i != 0)
	current_connection_name = current_connection_name + i;

    y2milestone("new rw %1", current_connection_name);
}

/** delete the given connection */
global void DeleteConnection(string name)
{
    if(!setCurrentConnection(name))
	return;

    // delete it from network config
    setNetworkDevicesUP([]);

    IPsecConfig::deleteConnection(name);
    connections = IPsecConfig::Connections();

    modified = true;
}

/** prepare a connection for editing
 * @param name name of the connection
 * @returns false if connection doesn't exist
 * */
global boolean setCurrentConnection(string name)
{
    if(name == nil || !haskey(connections, name))
    {
	setNoConnection();
	y2error("%1 not found in connections", name);
	return false;
    }

    current_connection = connections[name]:$[];
    current_connection_name = name;
    current_connection_oldname = "";

    return true;
}


/**
 * put current connection into key/value items suitable for a table
 * @return `item(`id("key"), "key", "value")
 * */
global list getCurrentConnectionItems()
{
    list items = [];
    foreach(string k, string v, current_connection, ``{
	items = add(items, `item(`id(k),k,v) );
    });

    return items;
}

/**
 * commit changes made to the current connection
 * */
global void commitChangedConnection()
{
    if(size(current_connection_oldname) != 0)
    {
	IPsecConfig::deleteConnection(current_connection_oldname);
    }

    IPsecConfig::addConnection(current_connection_name, current_connection);

    connections = IPsecConfig::Connections();

    modified = true;
}

/** return list of interface configuration */
global list getDevices()
{
    if(Mode::test == true)
	return [ "eth0", "dsl0" ];

    list devices = NetworkDevices::List("");

    devices = filter(string d, devices,``(d!="lo"));

    return devices;
}

/** return list of IP addresses of all configured interfaces */
global list getIPaddresses()
{
    list ips = [];

    if(Mode::test == true)
	return [ "10.10.1.1", "192.168.1.1" ];

    list devices = getDevices();

    foreach(string dev, devices, ``{
	if(!NetworkDevices::Select(dev)) continue;
	if(haskey(NetworkDevices::Current, "IPADDR"))
	    ips = add(ips, NetworkDevices::Current["IPADDR"]:"");
    });

    return ips;
}


/** return list of possible networks */
global list getNetworks()
{
    if(Mode::test == true)
	return [ "10.10.0.0/16", "192.168.1.0/24" ];

    list devices = getDevices();

    list nets = [];
    foreach(string dev, devices, ``{
	if(!NetworkDevices::Select(dev)) continue;
	if(haskey(NetworkDevices::Current, "IPADDR")
	    && haskey(NetworkDevices::Current, "NETMASK"))
	{
	    string ip = NetworkDevices::Current["IPADDR"]:"" + "/"
		+ Netmask::ToBits(NetworkDevices::Current["NETMASK"]:"");
	    nets = add(nets, ip);
	}
    });

    return nets;
}

/** return list of certificate filenames */
global list getCertificateFiles()
{
    list certs = [];

    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    foreach(string k, map v, certificates, ``{
	certs = add(certs, k);
    });
    return certs;
}


/** return list of DN and subjectAltNames (currently only one possible) */
global list getIdsOfCert(string name)
{
    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    if(size(name) == 0 || !haskey(certificates, name))
	return [];

    map cert = certificates[name]:$[];

    list ids = [];
    if(haskey(cert, "DN"))
	    ids = add(ids, cert["DN"]:"");
    if(haskey(cert, "subjectAltName"))
	    ids = add(ids, cert["subjectAltName"]:"");

    return ids;
}


/**
 * get list of network devices where the current connection is mentioned in FREESWAN_UP
 * */
global list<string> getNetworkDevicesUP()
{
    string conn = "";

    if(size(current_connection_oldname) != 0)
	conn = current_connection_oldname;
    else
	conn = current_connection_name;

    list devices = getDevices();

    list<string> devs = [];
    foreach(string dev, devices,
    ``{
	if(!NetworkDevices::Select(dev)) continue;

	if(!haskey(NetworkDevices::Current, "FREESWAN_UP"))
	    continue;

	list conns = sort(splitstring(NetworkDevices::Current["FREESWAN_UP"]:""," "));
	if(setcontains (conns, conn))
	    devs = add(devs, dev );
    });

    return devs;
}

/**
 * set FREESWAN_UP parameter in network devices. devices that mention the
 * current connection but are not passed to this function will have the current
 * connection removed.
 * @param devices list of devices where FREESWAN_UP should be present
 * */
global boolean setNetworkDevicesUP(list devices)
{
    list alldevices = getDevices();

    y2milestone("devices=%1", devices);

    devices = sort(devices);

    // we need to consider all devices since the connection could have been
    // deleted from some
    foreach(string dev, alldevices,
    ``{
	if(!NetworkDevices::Edit(dev)) continue;

	// no key and no device means nothing to add/delete
	if(!haskey(NetworkDevices::Current, "FREESWAN_UP")
	    && !setcontains (devices, dev))
	    continue;

	boolean devmodified = false;
	list<string> conns = sort(splitstring(NetworkDevices::Current["FREESWAN_UP"]:""," "));

	y2milestone("conns=%1", conns);

	// need to remove old name in any case
	if(size(current_connection_oldname) != 0
	    && setcontains (conns, current_connection_oldname))
	{
	    conns = filter(string c, conns, { return (c != current_connection_oldname); });
	    devmodified = true;
	}

	// remove from device?
	if(!setcontains (devices, dev)
	    && setcontains (conns, current_connection_name))
	{
	    conns = filter(string c, conns, { return (c != current_connection_name); });
	    devmodified = true;
	}

	// need to add new name?
	if(setcontains (devices, dev)
	    && !setcontains (conns, current_connection_name))
	{
	    conns = add(conns, current_connection_name);
	    devmodified = true;
	}

	y2milestone("conns=%1", conns);

	if(devmodified)
	{
	    NetworkDevices::Current["FREESWAN_UP"] = mergestring(conns, " ");
	    y2milestone("current=%1", NetworkDevices::Current);
	    NetworkDevices::Commit();
	}
    });

    return true;
}

/**
 * import certificate in PEM or DER format
 * @param filename file to import
 * @return nil on success, error string otherwise
 * */
global string importCertificate(string filename)
{
    if(filename == nil) return nil;
    return IPsecConfig::importCertificate(filename);
}

/**
 * import CA certificate in PEM or DER format
 * @param filename file to import
 * @return nil on success, error string otherwise
 * */
global string importCACertificate(string filename)
{
    // TODO
    if(filename == nil) return nil;
    return IPsecConfig::importCACertificate(filename);
}

/**
 * import CRL in PEM or DER format
 * @param filename file to import
 * @return nil on success, error string otherwise
 * */
global string importCRL(string filename)
{
    // TODO
    if(filename == nil) return nil;
    return IPsecConfig::importCRL(filename);
}

/**
 * import key in PEM or DER format
 * @param filename file to import
 * @param password key password. empty string for no password.
 * @return nil on success, error string otherwise
 * */
global string importKey(string filename, string password)
{
    // TODO
    if(filename == nil) return nil;
    return IPsecConfig::importKey(filename, password);
}

/* EOF */
}
