/**
 * File:	modules/IPsec.ycp
 * Package:	Configuration of ipsec
 * Summary:	IPsec settings, input and output functions
 * Authors:	Ludwig Nussel <lnussel@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of ipsec.
 * Input and output routines.
 */

{

module "IPsec";
textdomain "ipsec";

import "Progress";
import "Runlevel";
import "Report";
import "Summary";
import "Mode";
import "NetworkDevices";
import "Netmask";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}


/** do not set, use setstrictcrlpolicy */
global boolean strictcrlpolicy = false;

/** do not set, use setCrlCheckInterval */
global integer crlcheckinterval = 10;

/** do not set, use setNatTraversal */
global boolean nattraversal = false;

/** do not set, use setStart */
global boolean start = false;

global void setstrictcrlpolicy(boolean val)
{
    if(val != strictcrlpolicy)
    {
	modified = true;
	strictcrlpolicy = val;
    }
}

global void setStart(boolean val)
{
    if(val != start)
    {
	modified = true;
	start = val;
    }
}

global void setNatTraversal(boolean val)
{
    if(val != nattraversal)
    {
	modified = true;
	nattraversal = val;
    }
}

global void setCrlCheckInterval(integer val)
{
    if(val != crlcheckinterval)
    {
	modified = true;
	crlcheckinterval = val;
    }
}

/**
 * map of maps of strings
 * connections
 *  +-> "roadwarrior"
 *  |    +-> "left" = "10.10.0.1"
 *  |    +-> "right" = "%any"
 *  |    \-> "auto" = "start"
 *  |
 *  \-> "conn2"
 *       +-> "left" = "10.10.0.1"
 *       \-> "right" = "10.10.5.5"
 */
map connections = $[];

/** one connection, used during add or edit */
global map current_connection = $[];
global string current_connection_name = "";
// old name if connection was renamed
global string current_connection_oldname = "";

/** start directory for fileselection dialogs */
global string certimportdir = "/etc/ipsec.d"; //TODO change to /media

/** map of certificates
 * certificates
 * +-> "cert.pem"
 *      +-> "DN" = "/foo/bar/baz"
 *      \-> "subjectAltName" = "foo@bar"
 * */
map certificates = $[];
map cacertificates = $[];
map crls = $[];
map keys = $[];

list deletedcacerts = [];
list deletedcerts = [];
list deletedkeys = [];
list deletedcrls = [];

global string start_str = _("Activate during boot");
global string strictcrlpolicy_str =  _("strict CRL policy");
global string crlchekinterval_str =  _("CRL check interval");
global string nattraversal_str =  _("NAT traversal");
global string settings_str = _("FreeS/WAN settings");

/** return "Yes" or "No" */
string b2yn(boolean val)
{
    if (val == true)
	return _("Yes");
    return _("No");
}

/**
 */
map FakeConnections()
{
    return $[
	"roadwarrior" :
	    $[
		"left" : "%defaultroute",
		"right": "%any",
		"keyingtries": "3",
		"leftcert": "cert.pem",
		"leftrsasigkey": "%cert",
		"rightrsasigkey": "%cert",
		"pfs": "yes",
		"auto": "add",
	    ],
	"ipv6" :
	    $[
		"left" : "2001:780:101:a00:2e0:4cff:fe9f:619a",
		"right": "2001:780:101:a00:200:1cff:fee5:a796",
		"keyingtries": "3",
		"leftcert": "cert.pem",
		"leftrsasigkey": "%cert",
		"rightrsasigkey": "%cert",
		"leftid": "root@hewitt.suse.de",
		"rightid": "root@laptop",
		"pfs": "yes",
		"auto": "ignore",
	    ]
    ];
}

map FakeCertificates()
{
    return $[
	"cert.pem" :
	    $[
		"DN" : "/C=DE/ST=Franken/L=Nuernberg/O=SUSE/OU=Entwicklung/CN=hewitt.suse.de/emailAddress=root@hewitt.suse.de",
		"subjectAltName" : "root@hewitt.suse.de"
	    ]
    ];
}

map FakeCACertificates()
{
    return $[
	"cacert.pem" :
	    $[
		"DN" : "/C=DE/ST=Franken/L=Nuernberg/O=SUSE/OU=Entwicklung/CN=ca26test/emailAddress=root@hewitt.suse.de",
		"subjectAltName" : "root@hewitt.suse.de"
	    ]
    ];
}

map FakeCRLs()
{
    return $[
    ];
}

map FakeKeys()
{
    return $[
    ];
}

list bootmodes = [ "start", "add", "ignore" ];
list bootmodes_str = [ _("Initiate Connection"), _("Prepare Connection"), _("Ignore Connection") ];

/** return list of `item(`id("bootmode"), "text") */
global list getBootModeItems()
{
    integer i = 0;
    integer max = size(bootmodes);

    list items = [];

    while(i < max )
    {
	items = add(items, `item(`id(bootmodes[i]:""), bootmodes_str[i]:""));
	i = i + 1;
    }

    return items;
}

/** return text for bootmode, e.g. "auto" -> "initiate connection" */
global string getBootModeText(string mode)
{
    integer i = 0;
    integer max = size(bootmodes);

    while(i < max )
    {
	if(bootmodes[i]:"" == mode)
	    return bootmodes_str[i]:mode;
	i = i + 1;
    }

    return mode;
}

/** remember directory
 * @param file the file from which the directory name is stored
 * @return
 */
global boolean updateImportDir(string file)
{
    if(file == nil) return false;
    integer lastslash = findlastof(file,"/");
    if(lastslash != nil)
    {
	certimportdir = substring(file,0,lastslash);
    }
    return true;
}

/**
 * Read all ipsec settings
 * @return true on success
 */
global boolean Read() {

    /* IPsec read dialog caption */
    string caption = _("Initializing ipsec Configuration");

    // TODO FIXME Set the right number of stages
    integer steps = 4;

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read /etc/ipsec.conf"),
	    /* Progress stage 2/3 */
	    _("Read certificates"),
	    /* Progress stage 3/3 */
	    _("Read network settings")
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress step 2/3 */
	    _("Reading the previous settings..."),
	    /* Progress step 3/3 */
	    _("Reading network settings..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    if(Abort()) return false;
    Progress::NextStep();

    if(Mode::test == true)
    {
	connections = FakeConnections();
    }
    else
    {
	connections = (map)SCR::Read(.etc.ipsec.conf);
	if(connections == nil)
	    connections = $[];
    }

    if(Abort()) return false;
    Progress::NextStage();

    start = Runlevel::ServiceEnabled("ipsec");

    if(Mode::test == true)
    {
	certificates = FakeCertificates();
	cacertificates = FakeCACertificates();
	crls = FakeCRLs();
	keys = FakeKeys();
    }
    else
    {
	certificates = (map)SCR::Read(.etc.ipsec.d.certs);
	cacertificates = (map)SCR::Read(.etc.ipsec.d.cacerts);
	crls = (map)SCR::Read(.etc.ipsec.d.crls);
	keys = (map)SCR::Read(.etc.ipsec.d.private);

	if(certificates == nil) certificates = $[];
	if(cacertificates == nil) cacertificates = $[];
	if(crls == nil) crls = $[];
	if(keys == nil) keys = $[];
    }

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(_("Cannot read current settings."));

    // detect devices
    if(Abort()) return false;
    Progress::NextStage();

    if(!Mode::test && !NetworkDevices::Read())
    {
	Report::Warning(_("Cannot read network settings."));
    }


    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all ipsec settings
 * @return true on success
 */
global boolean Write()
{
    if(!modified) return true;

    /* IPsec read dialog caption */
    string caption = _("Saving IPsec Configuration");

    // TODO FIXME And set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // TODO FIXME Names of real stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // TODO
    SCR::Execute(.etc.ipsec.d, [ "deletecacerts", deletedcacerts ]);
    y2milestone("delete cacerts %1", deletedcacerts);
    SCR::Execute(.etc.ipsec.d, [ "deletecerts", deletedcerts ]);
    y2milestone("delete certs %1", deletedcerts);
    SCR::Execute(.etc.ipsec.d, [ "deletekeys", deletedkeys ]);
    y2milestone("delete keys %1", deletedkeys);
    SCR::Execute(.etc.ipsec.d, [ "deletecrls", deletedcrls ]);
    y2milestone("delete crls %1", deletedcrls);


    SCR::Write(.etc.ipsec.conf, connections);
    SCR::Write(.etc.ipsec.conf, nil);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/**
 * Get all ipsec settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the ipsec settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * @param conn a connection map
 * @param name localized name for summary
 * @param key key name in connection map
 * */
string addConnectionValueIfDefined(map conn, string name, string key)
{
    if(haskey(conn, key))
	return sformat("<li>%1: %2</li>", name, getBootModeText(conn[key]:""));
    return "";
}

/** create summary of connections */
string ConnectionSummary()
{
    string summary = sformat ("<p><a href=\"connections\">%1</a><br>", "Connections");
    summary = summary + "<ul>";

    if(size(connections) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No Connections defined"));
    }
    else
    {
	foreach(string name, map conn, connections, ``{
	    summary = summary + sformat("<li>%1</li>", name);
	    summary = summary + "<ul type=\"square\">";
	    summary = summary + addConnectionValueIfDefined(conn, _("Startmode"), "auto");
	    summary = summary + "</ul>";
	});
    }

    summary = summary + "</ul></p>";

    return summary;
}

/** create summary of connections */
string CertificateSummary()
{
    string summary = sformat ("<p><a href=\"certificates\">%1</a><br>", "Certificates");
    summary = summary + "<ul>";

    if(size(certificates) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No Certificates installed"));
    }
    else
    {
	foreach(string name, map cert, certificates, ``{
	    summary = summary + sformat("<li>%1: %2</li>", _("Certificate"), name);
	    summary = summary + "<ul type=\"square\">";
	    summary = summary + sformat("<li>Subject: %1</li>", cert["subjectAltName"]:"?");
	    summary = summary + sformat("<li>DN: %1</li>", cert["DN"]:"?");
	    summary = summary + "</ul>";
	});
    }

    if(size(cacertificates) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No CA Certificates installed"));
    }
    else
    {
	foreach(string name, map cert, cacertificates, ``{
	    summary = summary + sformat("<li>%1: %2</li>", _("CA Certificate"), name);
	    summary = summary + "<ul type=\"square\">";
	    summary = summary + sformat("<li>Subject: %1</li>", cert["subjectAltName"]:"?");
	    summary = summary + sformat("<li>DN: %1</li>", cert["DN"]:"?");
	    summary = summary + "</ul>";
	});
    }


    summary = summary + "</ul></p>";

    return summary;
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    /* Configuration summary text for autoyast */
    string summary = sformat ("<p><a href=\"settings\">%1</a><br>", settings_str);
    summary = summary + "<ul>";
    summary = summary + sformat("<li>%1: %2</li>", start_str, b2yn(start));
    summary = summary + sformat("<li>%1: %2</li>", strictcrlpolicy_str, b2yn(strictcrlpolicy));
    summary = summary + sformat("<li>%1: %2</li>", crlchekinterval_str, crlcheckinterval);
    summary = summary + sformat("<li>%1: %2</li>", nattraversal_str, b2yn(nattraversal));
    summary = summary + "</ul></p>";

    summary = summary + CertificateSummary();

    summary = summary + ConnectionSummary();

    return [ summary, [] ];
}

/**
 * Create an overview table with all configured connections
 * @return table items
 */
global list Overview() {
    list overview = [];

    foreach(string name, map conn, connections, ``{
	overview = add(overview, `item(`id(name), name, conn["left"]:"?", conn["right"]:"?"));
    });

    return overview;
}

global list CertOverview()
{
    list overview = [];

    foreach(string name, map cert, certificates, ``{
	overview = add(overview, `item(`id(name), name, cert["DN"]:"?"));
    });

    return overview;
}

global list CACertOverview()
{
    list overview = [];

    foreach(string name, map cert, cacertificates, ``{
	overview = add(overview, `item(`id(name), name, cert["DN"]:"?"));
    });

    return overview;
}

global list CRLOverview()
{
    list overview = [];

    foreach(string name, map cert, crls, ``{
	overview = add(overview, `item(`id(name), name, cert["NEXT_UPDATE"]:"?", cert["ISSUER"]:"?"));
    });

    return overview;
}

global list KeyOverview()
{
    list overview = [];

    foreach(string name, map cert, keys, ``{
	overview = add(overview, `item(`id(name), name));
    });

    return overview;
}

global void deleteCACert(string name)
{
    cacertificates = remove(cacertificates, name);
    deletedcacerts = add(deletedcacerts, name);
}

global void deleteCert(string name)
{
    certificates = remove(certificates, name);
    deletedcerts = add(deletedcerts, name);
}

global void deleteKey(string name)
{
    keys = remove(keys, name);
    deletedkeys = add(deletedkeys, name);
}

global void deleteCRL(string name)
{
    crls = remove(crls, name);
    deletedcrls = add(deletedcrls, name);
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    return $[ "install":[ "freeswan" ], "remove":[] ];
}

/**
 * empty any information about editing an existing connection
 * */
global void setNoConnection()
{
    current_connection = $[];
    current_connection_name = "";
    current_connection_oldname = "";
}

/** delete the given connection */
global void DeleteConnection(string name)
{
    connections = remove(connections, name);
    modified = true;
}

/** prepare a connection for editing
 * @param name name of the connection
 * @returns false if connection doesn't exist
 * */
global boolean setCurrentConnection(string name)
{
    current_connection_oldname = "";

    if(name == nil || !haskey(connections, name))
    {
	setNoConnection();
	y2error("%1 not found in connections", name);
	return false;
    }

    current_connection = connections[name]:$[];
    current_connection_name = name;

    return true;
}


/**
 * put current connection into key/value items suitable for a table
 * @return `item(`id("key"), "key", "value")
 * */
global list getCurrentConnectionItems()
{
    list items = [];
    foreach(string k, string v, current_connection, ``{
	items = add(items, `item(`id(k),k,v) );
    });

    return items;
}

/**
 * commit changes made to the current connection
 * */
global void commitChangedConnection()
{
    if(size(current_connection_oldname) != 0)
	connections = remove(connections, current_connection_oldname);

    connections = add(connections, current_connection_name, current_connection);
    modified = true;
}

/** return list of interface configuration */
global list getDevices()
{
    if(Mode::test == true)
	return [ "eth0", "dsl0" ];

    list devices = NetworkDevices::GetDevices("all");

    devices = filter(string d, devices,``(d!="lo"));

    return devices;
}

/** return list of IP addresses of all configured interfaces */
global list getIPaddresses()
{
    list ips = [];

    if(Mode::test == true)
	return [ "10.10.1.1", "192.168.1.1" ];

    list devices = getDevices();

    foreach(string dev, devices, ``{
	if(!NetworkDevices::Select(dev)) continue;
	if(haskey(NetworkDevices::Current, "IPADDR"))
	    ips = add(ips, NetworkDevices::Current["IPADDR"]:"");
    });

    return ips;
}


/** return list of possible networks */
global list getNetworks()
{
    if(Mode::test == true)
	return [ "10.10.0.0/16", "192.168.1.0/24" ];

    list devices = getDevices();

    list nets = [];
    foreach(string dev, devices, ``{
	if(!NetworkDevices::Select(dev)) continue;
	if(haskey(NetworkDevices::Current, "IPADDR")
	    && haskey(NetworkDevices::Current, "NETMASK"))
	{
	    string ip = NetworkDevices::Current["IPADDR"]:"" + "/"
		+ Netmask::ToBits(NetworkDevices::Current["NETMASK"]:"");
	    nets = add(nets, ip);
	}
    });

    return nets;
}

/** return list of certificate filenames */
global list getCertificateFiles()
{
    list certs = [];

    foreach(string k, map v, certificates, ``{
	certs = add(certs, k);
    });
    return certs;
}


/** return list of subjectAltNames (currently only one possible) */
global list getIdsOfCert(string name)
{
    if(size(name) == 0 || !haskey(certificates, name))
	return [];

    map cert = certificates[name]:$[];

    list ids = [];
    if(haskey(cert, "DN"))
	    ids = add(ids, cert["DN"]:"");
    if(haskey(cert, "subjectAltName"))
	    ids = add(ids, cert["subjectAltName"]:"");

    return ids;
}

/* EOF */
}
