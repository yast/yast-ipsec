/**
 * File:	modules/IPsec.ycp
 * Package:	Configuration of ipsec
 * Summary:	IPsec settings, input and output functions
 * Authors:	Ludwig Nussel <lnussel@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of ipsec.
 * Input and output routines.
 */

{

module "IPsec";
textdomain "ipsec";

import "IPsecConfig";
import "Progress";
import "Service";
import "Report";
import "Popup";
import "Summary";
import "Mode";
import "NetworkDevices";
import "Netmask";
import "SuSEFirewall";
import "Require";

/**
 * Prototypes
 */
global boolean Modified();

global list<string> getNetworkDevicesUP();
global list<string> getNetworkDevicesUP_conn(string name);
global boolean setNetworkDevicesUP(list devices);

global boolean setCurrentConnection(string name);

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/** flag whether first edit screen is displayed */
global boolean edit_start = false;

/** set to true to preselect a dialup interface */
global boolean dynamic_start_suggest_dialup = nil;

/** whether to silently change left to %dynamic if dynamic start is selected.
 * Used for easy client configuration */
global boolean silently_use_left_dynamic = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;


/** whether the user should be asked to reconfigure the firewall */
global boolean needaskfirewall = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    return AbortFunction();
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2milestone("modified=%1",modified);
    return modified;
}

/** whether the summary dialog already asked the user to import certificates */
global boolean didaskaboutemptycertificates = false;

/** whether the summary dialog already asked the user to add connections */
global boolean didaskaboutemptyconnections = false;


/** list of required packages */
list<string> requiredpackages = [ "freeswan" ];

/**
 * map of strings
 *  +-> "nat_traversal" = "yes"
 *  +-> "rp_filter" = "%unchanged"
 *  ...
 */
map<string, string> settings = $[];

/** default value. FIXME: get from lower layer? */
boolean default_strictcrlpolicy = false;

boolean strictcrlpolicy = false;

/** default value. FIXME: get from lower layer? */
integer default_crlcheckinterval = 0;

integer crlcheckinterval = 0;

/** default value. FIXME: get from lower layer? */
boolean default_nat_traversal = false;

boolean nat_traversal = false;

/** whether FreeS/WAN is started at boot */
boolean start = false;

/** whether to start FreeS/WAN at boot. Sets modified flag */
global void setStart(boolean val)
{
    if(val != start)
    {
	modified = true;
	start = val;
    }
}

/** determine whether FreeS/WAN is started at boot */
global boolean getStart()
{
    return start;
}

/** set strictcrlpolicy. Sets modified flag */
global void setStrictCRLPolicy(boolean val)
{
    if(val != strictcrlpolicy)
    {
	modified = true;
	strictcrlpolicy = val;
    }
}

/** @return whether strictcrlpolicy is set */
global boolean getStrictCRLPolicy()
{
    return strictcrlpolicy;
}

/** set nat_traversal. Sets modified flag */
global void setNatTraversal(boolean val)
{
    if(val != nat_traversal)
    {
	modified = true;
	nat_traversal = val;
    }
}

/** @return whether nat_traversal is set */
global boolean getNatTraversal()
{
    return nat_traversal;
}

/** set crlcheckinterval. Sets modified flag */
global void setCrlCheckInterval(integer val)
{
    if(val != crlcheckinterval)
    {
	modified = true;
	crlcheckinterval = val;
    }
}

/** @return crlcheckinterval */
global integer getCrlCheckInterval()
{
    return crlcheckinterval;
}

/**
 * map of maps of strings
 * connections
 *  +-> "roadwarrior"
 *  |    +-> "left" = "10.10.0.1"
 *  |    +-> "right" = "%any"
 *  |    \-> "auto" = "start"
 *  |
 *  \-> "conn2"
 *       +-> "left" = "10.10.0.1"
 *       \-> "right" = "10.10.5.5"
 */
map<string, map<string, string> > connections = $[];

/** one connection, used during add or edit */
global map<string,string> current_connection = $[];
global string current_connection_name = "";
// old name if connection was renamed
global string current_connection_oldname = "";

/** start directory for import fileselection dialogs */
global string certimportdir = "/media";

/** start directory for export fileselection dialogs */
global string exportdir = "/tmp";

global string start_str = _("Activate During Boot");
global string strictcrlpolicy_str =  _("Strict CRL Policy");
global string crlcheckinterval_str =  _("CRL Check Interval");
global string nattraversal_str =  _("NAT Traversal");
// Translator: Common in the sense of multiple items share the same settings.
// _not_ in the sense of "typical"
global string settings_str = _("Common Settings");

/** return "Yes" or "No" */
string b2yn(boolean val)
{
    if (val == true)
	return _("Yes");
    return _("No");
}

list bootmodes = [ "start", "add", "ignore" ];
list bootmodes_str = [ _("Initiate Connection"), _("Prepare Connection"), _("Ignore Connection") ];

/** return list of `item(`id("bootmode"), "text")
 * if current connection has right == %any, start will be omitted
 * */
global list getBootModeItems()
{
    integer i = 0;
    integer max = size(bootmodes);

    list items = [];

    // start is invalid for %any
    if(size(current_connection) > 0
	&& current_connection["right"]:"" == "%any")
    {
	i = i + 1;
    }

    while(i < max )
    {
	items = add(items, `item(`id(bootmodes[i]:""), bootmodes_str[i]:""));
	i = i + 1;
    }

    return items;
}

/** return text for bootmode, e.g. "auto" -> "initiate connection" */
global string getBootModeText(string mode)
{
    integer i = 0;
    integer max = size(bootmodes);

    while(i < max )
    {
	if(bootmodes[i]:"" == mode)
	    return bootmodes_str[i]:mode;
	i = i + 1;
    }

    return mode;
}

/** remember directory for import
 * @param file the file from which the directory name is stored
 * @return
 */
global boolean updateImportDir(string file)
{
    if(file == nil) return false;
    integer lastslash = findlastof(file,"/");
    if(lastslash != nil)
    {
	certimportdir = substring(file,0,lastslash);
    }
    return true;
}

/** remember directory for export
 * @param file the file from which the directory name is stored
 * @return
 */
global boolean updateExportDir(string file)
{
    if(file == nil) return false;
    integer lastslash = findlastof(file,"/");
    if(lastslash != nil)
    {
	exportdir = substring(file,0,lastslash);
    }
    return true;
}

/** get value from settings map an convert into integer */
integer settingtointeger(string key, integer deflt)
{
    if(!haskey(settings,key)) return deflt;

    integer val = tointeger(settings[key]:"");
    if(val == nil)
    {
	y2warning("key %s has no integer value", key);
	return deflt;
    }

    return val;
}

/** get value from settings map an convert into boolean */
boolean settingtoboolean(string key, boolean deflt)
{
    if(!haskey(settings,key)) return deflt;

    string val = tolower(settings[key]:"");

    if(val == "no" || val == "false" || val == "0")
    {
	return false;
    }
    else if(val == "yes" || val == "true" || val == "1")
    {
	return true;
    }
    else if(val == nil)
    {
	y2warning("key %s has no boolean value", key);
	return deflt;
    }
}

void settings_to_variables()
{
    strictcrlpolicy  = settingtoboolean("strictcrlpolicy", default_strictcrlpolicy);
    crlcheckinterval = settingtointeger("crlcheckinterval", default_crlcheckinterval);
    nat_traversal    = settingtoboolean("nat_traversal", default_nat_traversal);
}

/**
 * Read all ipsec settings
 * @return true on success
 */
global boolean Read() {

    /* IPsec read dialog caption */
    string caption = _("Initializing VPN Configuration");

    integer steps = 5;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/5 */
	    _("Check required packages"),
	    /* Progress stage 2/5 */
	    _("Read /etc/ipsec.conf"),
	    /* Progress stage 3/5 */
	    _("Read certificates"),
	    /* Progress stage 4/5 */
	    _("Read network settings"),
	    /* Progress stage 5/5 */
	    _("Read firewall settings"),
	], [
	    /* Progress step 1/5 */
	    _("Checking required packages..."),
	    /* Progress step 2/5 */
	    _("Reading the database..."),
	    /* Progress step 3/5 */
	    _("Reading the previous settings..."),
	    /* Progress step 4/5 */
	    _("Reading network settings..."),
	    /* Progress step 5/5 */
	    _("Reading firewall settings..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    if(Abort()) return false;
    Progress::NextStage();

    {
	if(!Require::AreAllPackagesInstalled(requiredpackages) )
	{
	    string help = _("FreeS/WAN is required for IPsec. Install the required packages now?");
	    if(!Require::RequireAndConflict( requiredpackages, [], help ) )
	    {
		if(!Require::LastOperationCanceled())
		    Report::Error (_("Failed to install required packages."));
		return false;
	    }
	}
    }

    if(Abort()) return false;
    Progress::NextStage();

    if(!IPsecConfig::Read())
	Report::Error(_("Unable to read IPsec settings. Error message was:")
	    + "\n" + IPsecConfig::LastError());

    connections = IPsecConfig::Connections();
    if(connections == nil)
	connections = $[];
    settings    = IPsecConfig::Settings();
    if(settings == nil) {
	settings = $[];
    }

    settings_to_variables();

    if(Abort()) return false;
    Progress::NextStage();

    if(Mode::test == true)
    {
	IPsecConfig::enableTestMode();
    }

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();

    start = Service::Enabled("ipsec");

    // detect devices
    if(Abort()) return false;
    Progress::NextStage();

    if(!Mode::test && !NetworkDevices::Read())
    {
	Report::Warning(_("Cannot read network settings."));
    }

    if(Abort()) return false;
    /* Firewall */
    Progress::NextStage();
    if(SuSEFirewall::Read() != true)
    {
	Report::Warning(_("Could not read firewall settings."));
    }

    needaskfirewall = (SuSEFirewall::start == true && SuSEFirewall::IsIPsecAllowed() != true);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    modified = false;
    return true;
}

/** no i18n */
string boolean2yesorno(boolean val)
{
    if(val)
	return "yes";
    return "no";
}

void variables_to_settings()
{
    settings["nat_traversal"] = boolean2yesorno(nat_traversal);
    settings["strictcrlpolicy"] = boolean2yesorno(strictcrlpolicy);
    settings["crlcheckinterval"] = sformat("%1", crlcheckinterval);
}

/**
 * Write all ipsec settings
 * @return true on success
 */
global boolean Write()
{
    if(!modified) return true;

    /* IPsec read dialog caption */
    string caption = _("Saving VPN Configuration");

    integer steps = 3;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Write IPsec settings"),
	    /* Progress stage 2/3 */
	    _("Write network settings"),
	    /* Progress stage 3/3 */
	    _("Adjust runlevel links")
	], [
	    /* Progress step 1/3 */
	    _("Writing IPsec settings..."),
	    /* Progress step 2/3 */
	    _("Writing network settings..."),
	    /* Progress step 2/3 */
	    _("Adjusting runlevel links..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    y2milestone("save ipsec.conf");

    variables_to_settings();

    IPsecConfig::setSettings(settings);

    IPsecConfig::Write();

    // Write Network settings
    if(Abort()) return false;
    Progress::NextStage ();

    y2milestone("write network settings");

    if(!NetworkDevices::Write(""))
	Report::Error (_("Writing network settings failed."));

    if(Abort()) return false;
    Progress::NextStage ();


    y2milestone("adjust runlevel links");

    if(start == true)
    {
	if(!Service::Enabled("ipsec"))
	{
	    if(!Service::Enable("ipsec"))
	    {
		Report::Error(_("Could not enable 'ipsec' boot script:") + Service::Error());
	    }
	}

	if(Service::Restart("ipsec") != true)
	{
	    // TODO: use output
	    Report::Error(_("Could not start IPsec."));
	}
    }
    else if(Service::Enabled("ipsec"))
    {
	if(!Service::Disable("ipsec"))
	{
	    Report::Error(_("Could not disable 'ipsec' boot script:") + Service::Error());
	}
	if(Service::Stop("ipsec") != true)
	{
	    // TODO: use output
	    Report::Error(_("Could not stop IPsec."));
	}
    }

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    return true;
}

/**
 * Get all ipsec settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map importsettings) {

    settings = importsettings["settings"]:$[];
    settings_to_variables();

    connections = importsettings["connections"]:$[];

    start = importsettings["start"]:false;

    return true;
}

/**
 * Dump the ipsec settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[
	"settings" : settings,
	"connections" : connections,
	"start" : start,
    ];
}

/**
 * @param conn a connection map
 * @param name localized name for summary
 * @param key key name in connection map
 * */
string addConnectionValueIfDefined(map conn, string name, string key)
{
    if(haskey(conn, key))
	return sformat("<li>%1: %2</li>", name, getBootModeText(conn[key]:""));
    return "";
}

/**
 * add hyperlink or headline 3
 * @param link link destination
 * @param text link text
 * @param href set to true if hyperlink should be created, false for headline
 * */
string MaybeHref(string link, string text, boolean href)
{
    string line = "";

    if(href)
	line = sformat ("<p><a href=\"%1\">%2</a><br>", link, text);
    else
	line = "<h3>" + text + "</h3>";

    return line;
}

/** create summary of connections */
string ConnectionSummary(boolean href)
{
    string summary = "";

    summary = summary + MaybeHref("connections", _("Connections"), href);

    summary = summary + "<ul>";

    if(size(connections) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No connections defined"));
    }
    else
    {
	foreach(string name, map conn, connections, ``{

	    string text = "";
	    if(conn["right"]:"" == "%any")
	    {
		text = _("Accept Client Connections");
	    }
	    else
	    {
		// %1 = IP Adress or hostname
		text = sformat(_("Establish Connection with %1"), conn["right"]:_("Unknown"));
	    }
	    summary = summary + sformat("<li>%1: %2</li>", name, text);
	});
    }

    summary = summary + "</ul></p>";

    return summary;
}

/** create summary of certificates */
string CertificateSummary(boolean href)
{
    string summary =  "";

    summary = summary + MaybeHref("certificates", _("Certificates"), href);

    summary = summary + "<ul>";

    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    if(size(certificates) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No certificates installed."));
    }
    else
    {
	foreach(string name, map cert, certificates, ``{
	    summary = summary + sformat("<li>%1: %2</li>", _("Certificate"), cert["subjectAltName"]:"?");
	});
    }

    map<string,map<string,string> > cacertificates = IPsecConfig::CACertificates();

    if(size(cacertificates) == 0)
    {
	summary = summary + sformat("<li><font color=\"red\">%1</font></li>", _("No CA certificates installed."));
    }
    else
    {
	foreach(string name, map cert, cacertificates, ``{
	    summary = summary + sformat("<li>%1: %2</li>", _("CA Certificate"), cert["subjectAltName"]:"?");
	});
    }

    summary = summary + "</ul></p>";

    return summary;
}

/** create summary of settings */
string SettingsSummary(boolean href)
{
    boolean scpchanged = getStrictCRLPolicy() != default_strictcrlpolicy;
    boolean ntchanged  = getNatTraversal() != default_nat_traversal;
    boolean cichanged  = getCrlCheckInterval() != default_crlcheckinterval;

    string summary = "";

    summary = summary + MaybeHref("settings", settings_str, href);

    summary = summary + "<ul>";
    if(scpchanged || ntchanged || cichanged)
    {
	summary = summary + sformat("<li>%1: %2</li>", nattraversal_str, b2yn(getNatTraversal()));
	summary = summary + sformat("<li>%1: %2</li>", strictcrlpolicy_str, b2yn(getStrictCRLPolicy()));
	if(cichanged)
	{
	    summary = summary + sformat("<li>%1: %2</li>", crlcheckinterval_str,
		sformat(_("%1 second", "%1 seconds", getCrlCheckInterval()), getCrlCheckInterval()));
	}
    }
    else
    {
	// Translator: Defaults means default settings are currently beeing used
	summary = summary + sformat("<li>%1</li>", _("Defaults"));
    }
    summary = summary + "</ul></p>";

    return summary;
}

/**
 * Textual summary for standalone Module
 * @return summary of the current configuration
 */
global string MainSummary()
{
    string summary = "";

    summary = summary + ConnectionSummary(true);

    summary = summary + CertificateSummary(true);

    summary = summary + SettingsSummary(true);

    return summary;
}

/**
 * Textual summary for auto installation and proposal
 * @return summary of the current configuration
 */
global list Summary()
{
    string summary = "";

    if(start)
    {
	summary = summary + ConnectionSummary(false);

	summary = summary + CertificateSummary(false);

	summary = summary + SettingsSummary(false);
    }
    else
    {
	summary = summary + _("VPN service is disabled.");
    }

    return [ summary, [] ];
}

/** returns whether there are connections at all */
global boolean haveConnections()
{
    return (size(connections) > 0);
}

/** returns whether there are certificates at all */
global boolean haveCertificates()
{
    return (size(IPsecConfig::Certificates()) > 0);
}

/**
 * Create an overview table with all configured connections
 * @return table items
 */
global list Overview() {
    list overview = [];

    foreach(string name, map conn, connections, ``{
	overview = add(overview,
	    `item(`id(name),
		name,
		conn["left"]:"?",
		conn["right"]:"?",
		getBootModeText(conn["auto"]:"?"),
		mergestring(getNetworkDevicesUP_conn(name), ", ")
	    ));
	});

    return overview;
}

/** remove /etc/ipsec.d/{certs,cacerts,private,crls}
 * @param absolute path name
 * @return simple filename if absolute is one of the above four directories
 * */
string CertFileNameToDisplayName(string name)
{
    if(substring(name, 0, 1) != "/")
	return name;

    list token = splitstring(name,"/");

    if(size(token) != 5)
	return name;

    string subdir = token[3]:"";
    if(token[1]:"" == "etc" && token[2]:"2" == "ipsec.d"
	&& (subdir == "certs" || subdir == "private" || subdir == "cacerts" || subdir == "crls"))
    {
	return token[4]:name;
    }
    else
    {
	return name;
    }
}

global list CertOverview()
{
    list overview = [];

    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    foreach(string name, map cert, certificates, ``{
	string new = " ";
	if(haskey(cert,"NEW")) new = UI::Glyph(`BulletArrowRight);
	string displayname = CertFileNameToDisplayName(name);
	overview = add(overview, `item(`id(name), new, displayname, cert["DN"]:"?"));
    });

    return overview;
}

global list CACertOverview()
{
    list overview = [];

    map<string,map<string,string> > cacertificates = IPsecConfig::CACertificates();

    foreach(string name, map cert, cacertificates, ``{
	string new = " ";
	if(haskey(cert,"NEW")) new = UI::Glyph(`BulletArrowRight);
	string displayname = CertFileNameToDisplayName(name);
	overview = add(overview, `item(`id(name), new, displayname, cert["DN"]:"?"));
    });

    return overview;
}

global list CRLOverview()
{
    list overview = [];

    map<string,map<string,string> > crls = IPsecConfig::CRLs();

    foreach(string name, map cert, crls, ``{
	string new = " ";
	if(haskey(cert,"NEW")) new = UI::Glyph(`BulletArrowRight);
	string displayname = CertFileNameToDisplayName(name);
	overview = add(overview, `item(`id(name), new, displayname, cert["NEXT_UPDATE"]:"?", cert["ISSUER"]:"?"));
    });

    return overview;
}

global list KeyOverview()
{
    list overview = [];

    map<string,map<string,string> > keys = IPsecConfig::Keys();

    foreach(string name, map cert, keys, ``{
	string new = " ";
	if(haskey(cert,"NEW")) new = UI::Glyph(`BulletArrowRight);
	string displayname = CertFileNameToDisplayName(name);
	overview = add(overview, `item(`id(name), new, displayname));
    });

    return overview;
}

global void deleteCACert(string name)
{
    IPsecConfig::deleteCACertificate(name);
}

global void deleteCert(string name)
{
    IPsecConfig::deleteCertificate(name);
}

global void deleteKey(string name)
{
    IPsecConfig::deleteKey(name);
}

global void deleteCRL(string name)
{
    IPsecConfig::deleteCRL(name);
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    return $[ "install":requiredpackages, "remove":[] ];
}

/**
 * empty any information about editing an existing connection
 * */
global void setNoConnection()
{
    current_connection = $[];
    current_connection_name = "";
    current_connection_oldname = "";
    dynamic_start_suggest_dialup = nil;
    silently_use_left_dynamic = false;
}

/**
 * prepare a new connection for editing
 * */
global void newConnection()
{
    current_connection = IPsecConfig::newServerConnection();
    current_connection_name = "";
    current_connection_oldname = "";
    dynamic_start_suggest_dialup = nil;
    silently_use_left_dynamic = false;
}

global void newServerConnection()
{
    current_connection = IPsecConfig::newServerConnection();
    current_connection_name = "roadwarrior";
    current_connection_oldname = "";
    dynamic_start_suggest_dialup = nil;
    silently_use_left_dynamic = false;

    integer i = 0;
    foreach(string name, map conn, connections, ``{
	if(substring(name, 0, 11) == "roadwarrior")
	{
	    i = i + 1;
	}
    });

    if(i != 0)
	current_connection_name = current_connection_name + i;

    y2milestone("new rw %1", current_connection_name);
}

global void newClientConnection()
{
    current_connection = IPsecConfig::newClientConnection();
    current_connection_name = "clientserver";
    current_connection_oldname = "";
    dynamic_start_suggest_dialup = nil;
    silently_use_left_dynamic = true;

    integer i = 0;
    foreach(string name, map conn, connections, ``{
	if(substring(name, 0, 12) == "clientserver")
	{
	    i = i + 1;
	}
    });

    if(i != 0)
	current_connection_name = current_connection_name + i;

    y2milestone("new client %1", current_connection_name);
}

/** delete the given connection */
global void DeleteConnection(string name)
{
    if(!setCurrentConnection(name))
	return;

    // delete it from network config
    setNetworkDevicesUP([]);

    IPsecConfig::deleteConnection(name);
    connections = IPsecConfig::Connections();

    modified = true;
}

/** prepare a connection for editing
 * @param name name of the connection
 * @returns false if connection doesn't exist
 * */
global boolean setCurrentConnection(string name)
{
    if(name == nil || !haskey(connections, name))
    {
	setNoConnection();
	y2error("%1 not found in connections", name);
	return false;
    }

    current_connection = connections[name]:$[];
    current_connection_name = name;
    current_connection_oldname = "";

    return true;
}

/**
 * Check whether the currently selection Connection can be edited. Currently
 * only x509 connections may be edited
 * @return nil if ok, message why it is not possible otherwise
 * */
global string mayEditCurrentConnection()
{
    if(current_connection_name == "") return nil;
    if(current_connection["leftrsasigkey"]:"%cert" != "%cert"
	|| current_connection["rightrsasigkey"]:"%cert" != "%cert")
    {
	return _("The selected connection does not use certificates for authentication.")+ "\n"
		+ _("You can only edit connections that use certificates.");
    }

    return nil;
}

/**
 * put current connection into key/value items suitable for a table
 * @return `item(`id("key"), "key", "value")
 * */
global list getCurrentConnectionItems()
{
    list items = [];
    foreach(string k, string v, current_connection, ``{
	items = add(items, `item(`id(k),k,v) );
    });

    return items;
}

/**
 * commit changes made to the current connection
 * */
global void commitChangedConnection()
{
    if(size(current_connection_oldname) != 0)
    {
	IPsecConfig::deleteConnection(current_connection_oldname);
    }

    IPsecConfig::addConnection(current_connection_name, current_connection);

    connections = IPsecConfig::Connections();

    modified = true;
}

/** return list of interface configuration */
global list<string> getDevices()
{
    if(Mode::test == true)
	return [ "eth0", "dsl0" ];

    list<string> devices = (list<string>)NetworkDevices::List("");

    devices = filter(string d, devices,``(d!="lo"));

    return devices;
}

/** return list of IP addresses of all configured interfaces */
global list getIPaddresses()
{
    list ips = [];

    if(Mode::test == true)
	return [ "10.10.1.1", "192.168.1.1" ];

    list<string> devices = getDevices();

    foreach(string dev, devices, ``{
	if(!NetworkDevices::Select(dev)) continue;
	if(haskey(NetworkDevices::Current, "IPADDR"))
	    ips = add(ips, NetworkDevices::Current["IPADDR"]:"");
    });

    return ips;
}


/** return list of possible networks */
global list getNetworks()
{
    if(Mode::test == true)
	return [ "10.10.99.0/16", "192.168.88.0/24" ];

    list<string> devices = getDevices();

    list nets = [];
    foreach(string dev, devices, ``{
	if(!NetworkDevices::Select(dev)) continue;
	if(haskey(NetworkDevices::Current, "NETWORK")
	    && haskey(NetworkDevices::Current, "NETMASK"))
	{
	    string ip = NetworkDevices::Current["NETWORK"]:"" + "/"
		+ Netmask::ToBits(NetworkDevices::Current["NETMASK"]:"");
	    nets = add(nets, ip);
	}
    });

    return nets;
}

/** return list of certificate filenames */
global list getCertificateFiles()
{
    list certs = [];

    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    foreach(string k, map v, certificates, ``{
	certs = add(certs, k);
    });
    return certs;
}

string removesubaltnameprefix(string s)
{
    list<string> tostrip = [ "email:", "ip address:", "dns:" ];
    foreach(string pattern, tostrip,
    ``{
	y2milestone("%1", tolower(substring(s, 0, size(pattern))));
	if(tolower(substring(s, 0, size(pattern))) == pattern)
	{
	    s = substring(s, size(pattern));
	    break;
	}
    });

    return s;
}

/** return list of subjectAltName(s) and DN.
 * SubjectAltName is first if available since it's usually an EMail Address
 * (YaST2 CA module only supports EMail addresses) */
global list<string> getIdsOfCert(string name)
{
    map<string,map<string,string> > certificates = IPsecConfig::Certificates();

    if(size(name) == 0 || !haskey(certificates, name))
	return [];

    map<string,string> cert = certificates[name]:$[];

    list<string> ids = [];
    string altname = nil;
    if(haskey(cert, "subjectAltName"))
    {
	altname = cert["subjectAltName"]:nil;
    }

    if(altname != nil)
    {
	while(true)
	{
	    integer pos = find(altname, ", ");
	    if(pos == -1) break;

	    string s = substring(altname, 0, pos);
	    altname = substring(altname, pos+2);

	    s = removesubaltnameprefix(s);
	    if(s != "")
		ids = add(ids, s);
	}

	altname = removesubaltnameprefix(altname);
	if(altname != "")
	    ids = add(ids, altname);
    }

    if(haskey(cert, "DN") && cert["DN"]:nil != nil)
	ids = add(ids, cert["DN"]:"");

    return ids;
}

/**
 * get list of network devices where the specified connection is menioned in FREESWAN_UP
 * */
global list<string> getNetworkDevicesUP_conn(string conn)
{
    list<string> devices = getDevices();

    list<string> devs = [];
    foreach(string dev, devices,
    ``{
	if(!NetworkDevices::Select(dev)) continue;

	if(!haskey(NetworkDevices::Current, "FREESWAN_UP"))
	    continue;

	list conns = sort(splitstring(NetworkDevices::Current["FREESWAN_UP"]:""," "));
	if(setcontains (conns, conn))
	    devs = add(devs, dev );
    });

    return devs;
}

/**
 * get list of network devices where the current connection is mentioned in FREESWAN_UP
 * */
global list<string> getNetworkDevicesUP()
{
    string conn = "";

    if(size(current_connection_oldname) != 0)
	conn = current_connection_oldname;
    else
	conn = current_connection_name;

    return getNetworkDevicesUP_conn(conn);
}

/**
 * set FREESWAN_UP parameter in network devices. devices that mention the
 * current connection but are not passed to this function will have the current
 * connection removed.
 * @param devices list of devices where FREESWAN_UP should be present
 * */
global boolean setNetworkDevicesUP(list devices)
{
    list<string> alldevices = getDevices();

    y2milestone("devices=%1", devices);

    devices = sort(devices);

    // we need to consider all devices since the connection could have been
    // deleted from some
    foreach(string dev, alldevices,
    ``{
	if(!NetworkDevices::Edit(dev)) continue;

	// no key and no device means nothing to add/delete
	if(!haskey(NetworkDevices::Current, "FREESWAN_UP")
	    && !setcontains (devices, dev))
	    continue;

	boolean devmodified = false;
	list<string> conns = sort(splitstring(NetworkDevices::Current["FREESWAN_UP"]:""," "));

	y2milestone("conns=%1", conns);

	// need to remove old name in any case
	if(size(current_connection_oldname) != 0
	    && setcontains (conns, current_connection_oldname))
	{
	    conns = filter(string c, conns, { return (c != current_connection_oldname); });
	    devmodified = true;
	}

	// remove from device?
	if(!setcontains (devices, dev)
	    && setcontains (conns, current_connection_name))
	{
	    conns = filter(string c, conns, { return (c != current_connection_name); });
	    devmodified = true;
	}

	// need to add new name?
	if(setcontains (devices, dev)
	    && !setcontains (conns, current_connection_name))
	{
	    conns = add(conns, current_connection_name);
	    devmodified = true;
	}

	y2milestone("conns=%1", conns);

	if(devmodified)
	{
	    NetworkDevices::Current["FREESWAN_UP"] = mergestring(conns, " ");
	    y2milestone("current=%1", NetworkDevices::Current);
	    NetworkDevices::Commit();
	}
    });

    return true;
}

/** find first dialup interface and return it.
 * */
global list<string> getDialupInterfaces()
{
    list<string> alldevices = getDevices();
    list<string> ret = [];

    foreach(string dev, alldevices,
    ``{
	if(NetworkDevices::GetValue(dev, "PROVIDER") != "")
	    ret = add(ret, dev);
    });

    return ret;
}

/** return text: <value of setting> if setting is in current connection */
string ConnectionAsText_additem(string text, string setting)
{
    if(!haskey(current_connection, setting))
	return "";

    string val = current_connection[setting]:nil;

    if(val == "%defaultroute" || val == "%dynamic" || val == "%any")
	return "";

    return sformat("<b>%1</b> %2<br>", text, val );
}

/** create a detailed richttext summary of the current connection */
global string ConnectionAsText()
{
    string text = "";

    text = text + ConnectionAsText_additem(_("Address:"), "left");
    text = text + ConnectionAsText_additem(_("Identification:"), "leftid");
    text = text + ConnectionAsText_additem(_("Network:"), "leftsubnet");
    text = text + ConnectionAsText_additem(_("Remote Address:"), "right");
    text = text + ConnectionAsText_additem(_("Remote Identification:"), "rightid");
    text = text + ConnectionAsText_additem(_("Remote Network:"), "rightsubnet");
    text = text + "<br>";
    text = text + ConnectionAsText_additem(_("Encryption Algorithms:"), "esp");
    // Translator: probably not translatable, technical term
    text = text + ConnectionAsText_additem(_("Perfect Forward Secrecy:"), "pfs");
    text = text + ConnectionAsText_additem(_("Keying Tries:"), "keyingtries");

    return text;
}

/* EOF */
}
